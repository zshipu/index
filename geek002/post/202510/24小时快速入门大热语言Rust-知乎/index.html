<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="baidu-site-verification" content="codeva-odZno92jxn" />
<meta name="360-site-verification" content="b46a7087f21ff6cf8dcee8ee59ee9a61" />
<meta name="sogou_site_verification" content="F2mmMQ4NdU" />

    <title> | 知识铺的博客</title>
    <meta property="og:title" content=" - 知识铺的博客">
    <meta property="og:type" content="article">

    
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="">
    
    <meta name="author" content="知识铺">
    <meta property="og:url" content="https://index.zshipu.com/geek002/post/202510/24%E5%B0%8F%E6%97%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%A4%A7%E7%83%AD%E8%AF%AD%E8%A8%80Rust-%E7%9F%A5%E4%B9%8E/">
    <link rel="shortcut icon" href='/geek002/favicon.ico' type="image/x-icon">

    <link rel="stylesheet" href='/geek002/css/normalize.css'>
    <link rel="stylesheet" href='/geek002/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    

    

    
    
    
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-WLWJSST');</script>
    
</head>

<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://index.zshipu.com/geek002/">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://index.zshipu.com/geek002/">首页</a>
                    
                    <a  href="https://index.zshipu.com" title="总站">总站</a>
                    
                    <a  href="https://index.zshipu.com/geek001/" title="技术">技术</a>
                    
                    <a  href="https://index.zshipu.com/geek002/archives/" title="归档">归档</a>
                    
                    <a  href="https://index.zshipu.com/geek002/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一基础篇">一、基础篇</a></li>
        <li><a href="#11-rust的安装与基本工具的使用">1.1 Rust的安装与基本工具的使用</a></li>
        <li><a href="#12-通过greplite小程序熟悉rust的语言特点">1.2 通过greplite小程序熟悉Rust的语言特点</a></li>
        <li><a href="#13-rust中组织数据的3种方式">1.3 Rust中组织数据的3种方式</a></li>
        <li><a href="#14-rust中的ownership">1.4 Rust中的Ownership</a></li>
        <li><a href="#15-rust中的引用和借用">1.5 Rust中的引用和借用</a></li>
        <li><a href="#16-trait">1.6 trait</a></li>
        <li><a href="#17-迭代器">1.7 迭代器</a></li>
        <li><a href="#18-闭包">1.8 闭包</a></li>
        <li><a href="#19-sync--send">1.9 Sync &amp; Send</a></li>
        <li><a href="#110-async--await">1.10 async &amp; await</a></li>
        <li><a href="#二思维篇">二、思维篇</a></li>
        <li><a href="#21-expression">2.1 expression</a></li>
        <li><a href="#22-split">2.2 split</a></li>
        <li><a href="#23-无处不在的option和result">2.3 无处不在的Option和Result</a></li>
        <li><a href="#24-match的不仅仅是enum">2.4 match的不仅仅是enum</a></li>
        <li><a href="#25-宏强大的超乎想象">2.5 宏强大的超乎想象</a></li>
        <li><a href="#26-通过传递消息的方式共享内存">2.6 通过传递消息的方式共享内存</a></li>
        <li><a href="#27-和c一致的内存模型">2.7 和C++一致的内存模型</a></li>
        <li><a href="#28-interior-mutability-pattern">2.8 Interior Mutability Pattern</a></li>
        <li><a href="#29-buildrs在编译期执行各种操作">2.9 build.rs在编译期执行各种操作</a></li>
        <li><a href="#210-迭代器真的很好用">2.10 迭代器真的很好用</a></li>
        <li><a href="#211-想定义个全局变量真不容易">2.11 想定义个全局变量真不容易</a></li>
        <li><a href="#三实战篇">三、实战篇</a></li>
        <li><a href="#rust学习建议">Rust学习建议</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title"></h1>
        </header>
        <date class="post-meta meta-date">
            1年1月1日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p>作者：richardyao</p>
<blockquote>
<p>最近几年，Rust在业界的使用越来越多，本篇文章从Rust核心语法等基础知识入手，进而详细的介绍Rust语言不同于其它语言的思维方式，最后通过一个实战的项目，带大家快速入门Rust编程语言。</p>
</blockquote>
<p>最近几年，Rust在业界的使用越来越多。在Windows内核中(win32kbase_rs.sys)、Linux内核中、Chromium浏览器中都有Rust的身影，AWS S3也使用rust重构了他们的核心存储服务ShardStore，Azure的CTO甚至说&quot;Speaking of languages, it&rsquo;s time to halt starting any new projects in C/C++ and use Rust for those scenarios where a non-GC language is required.&quot;。从下面的Google Trends也可以看的出来，Rust的热度正在上升，并且增长很快，可以说现在是学习Rust最好的时机。</p>
<p>
        <img class="mx-auto" alt="" src="https://pica.zhimg.com/v2-8ab24710819da7d29cc7f87063316a9e_1440w.jpg" />   
    </p>
<p>本篇文章从Rust核心语法等基础知识入手，进而详细的介绍Rust语言不同于其它语言的思维方式，最后通过一个实战的项目，带大家快速入门Rust编程语言。</p>
<p>有C++、Golang、Python这些语言基础的话，大部分知识都可以迁移过去，再加上大模型的辅助，24小时快速入门，是有可能达成的。</p>
<h3 id="一基础篇">一、基础篇</h3>
<h3 id="11-rust的安装与基本工具的使用">1.1 Rust的安装与基本工具的使用</h3>
<p>Rust的安装直接参考官网的文档，这里不做更具体的介绍了：</p>
<p><a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>
<p>在国内使用Rust的话，可以通过 <a href="https://rsproxy.cn/">RsProxy</a> 网站提供的镜像，更方便快捷的安装Rust以及下载相关的crate等。</p>
<p>Rust对应的编译器是rustc，但是这个大家平时使用的并不多，更多的是通过包管理工具cargo等来管理、构建项目。cargo常用命令如下：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>cargo build cargo build --release cargo clippy cargo run cargo run -- --help cargo clean cargo check cargo doc cargo expand # 需要使用cargo install cargo-expand先安装
</span></span></code></pre></td></tr></table>
</div>
</div><p>Rust日常开发可以使用vscode + rust-analyzer插件。</p>
<h3 id="12-通过greplite小程序熟悉rust的语言特点">1.2 通过greplite小程序熟悉Rust的语言特点</h3>
<p>在这里，我们使用一个简单greplite程序来介绍Rust语言的特点。</p>
<p>先使用<code>cargo new greplite</code>命令创建一个binary的crate，然后在main.rs中输入下面的代码：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>use std::env; use std::fs::File; use std::io::{self, BufRead, BufReader}; fn main() -&gt; io::Result&lt;()&gt; { let args = env::args().collect::&lt;Vec&lt;_&gt;&gt;(); if args.len() &lt; 3 { eprintln!(&#34;Usage: greplite &lt;search_string&gt; &lt;file_path&gt;&#34;); std::process::exit(1); } let search_string = &amp;args[1]; let file_path = &amp;args[2]; run(search_string, file_path) } fn run(search_string: &amp;str, file_path: &amp;str) -&gt; io::Result&lt;()&gt; { let file = File::open(file_path)?; let reader = BufReader::new(file); for line in reader.lines() { let line = line?; if line.contains(search_string) { println!(&#34;{line}&#34;); } } Ok(()) }
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个程序的第一个参数是要搜索的字符串，第二个参数是搜索的文件，比如说要搜索src/main.rs文件中包含main函数的行，可以如下执行：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>$ cargo run -- main src/main.rs Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/greplite main src/main.rs` fn main() -&gt; io::Result&lt;()&gt; {
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个小程序一共就30行代码，但是知识点还挺多的，先整体介绍一下：</p>
<p>a)、use类似于C++中的include，用来引用std标准库里面的module；</p>
<p>b)、fn用来定义一个函数，main函数是整个程序的入口；</p>
<p>c)、<code>-&gt;</code>表示函数的返回值，<code>io::Result&lt;()&gt;</code>表示返回的是个<code>Result</code>，通过文档，或者vscode代码跳转的方式，可以看到<code>std::io::Result&lt;T&gt;</code>是基于<code>std::result::Result&lt;T, std::io::Error&gt;</code>定义的一个新类型</p>
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html">https://doc.rust-lang.org/std/io/type.Result.html</a></p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>pub type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>同时<code>std::result::Result</code>是一个枚举：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>pub enum Result&lt;T, E&gt; { Ok(T), Err(E), }
</span></span></code></pre></td></tr></table>
</div>
</div><p>Result表示的值，可以是表示成功的Ok，也可以是表示失败的Err。</p>
<p>上面<code>pub type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;</code>只是把<code>std::io::Result</code>的错误类型固定成<code>std::io::Error</code>，表示只会返回<code>std::io::Error</code>类型的错误。</p>
<p>d)、<code>io::Result&lt;()&gt;</code>中的<code>()</code>，表示的是一个tuple，这个tuple没有任何元素，也称为unit；</p>
<p>e)、关于main函数的返回类型：</p>
<p><a href="https://doc.rust-lang.org/reference/crates-and-source-files.html?highlight=main#main-functions">Crates and source files</a></p>
<p>f)、<code>let args = env::args().collect::&lt;Vec&lt;_&gt;&gt;();</code>中的env::args()返回的值，实现了Iterator这个trait，关于Rust中的迭代器，后面还会重点来讲，这个collect是把迭代器的列表收集起来，构造成一个Vec。</p>
<p>这个语句还有下面几种写法，都是可以的：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let args = env::args().collect::&lt;Vec&lt;_&gt;&gt;(); let args = env::args().collect::&lt;Vec&lt;String&gt;&gt;(); let args: Vec&lt;String&gt; = env::args().collect(); let args: Vec&lt;_&gt; = env::args().collect();
</span></span></code></pre></td></tr></table>
</div>
</div><p>Rust的类型推断是非常强大的，如果后面对args的使用能确定args的类型的话，也可以完全写成：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let args = env::args().collect();
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如说如果有函数<code>fn print_args(args: &amp;Vec&lt;String&gt;) {}</code>，同时后面调用了<code>print_args(&amp;args)</code>的话，args的定义就完全不需要类型注解了。</p>
<p>另外，通过let定义的变量，默认是不可变的(immutable)，如果要修改的话，需要显示的使用<code>let mut args = env::args().collect();</code></p>
<p>这里还有一个知识点，我们在前面并没有通过use语句引入Vec，那为什么不报错呢？</p>
<p><a href="https://doc.rust-lang.org/std/prelude/index.html">https://doc.rust-lang.org/std/prelude/index.html</a></p>
<p>Rust编译器预先已经包含了std中部分常用的组件，这样代码会更简洁一些。</p>
<p>g)、<code>args.len()</code>中的len()是<code>Vec&lt;String&gt;</code>的成员函数 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.len">https://doc.rust-lang.org/std/vec/struct.Vec.html#method.len</a>；</p>
<p>h)、<code>let search_string = &amp;args[1];</code>和<code>let file_path = &amp;args[2];</code>这里定义了两个引用，是对<code>Vec&lt;String&gt;</code>中对应元素的不可变的借用；</p>
<p><code>args[1]</code>下标操作，在运行时会check下标是否越界，但是由于前面判断了长度，因此这里的运行时的越界检查，编译器通常会优化掉。</p>
<p>i)、下面是调用run函数，另外这里是一个expression，expression的值作为整个main函数的返回值；</p>
<p>j)、第19行<code>let file = File::open(file_path)?;</code>打开一个文件，这个语句中的<code>?</code>是一个语法糖，这条语句等价于：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let file = match File::open(file_path) { Ok(f) =&gt; f, Err(err) =&gt; return Err(From::from(err)), };
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html?highlight=question#the-question-mark-operator">https://doc.rust-lang.org/reference/expressions/operator-expr.html?highlight=question#the-question-mark-operator</a></p>
<p>h)、第20行<code>let reader = BufReader::new(file);</code>file实现了Read这个trait，然后BufReader是在Read这个trait的基础上，做了一层封装，实现了带缓存的读，并在此基础上，提供了lines()等便捷的方法。</p>
<p><a href="https://doc.rust-lang.org/std/fs/struct.File.html#impl-Read-for-File">https://doc.rust-lang.org/std/fs/struct.File.html#impl-Read-for-File</a></p>
<p>BufReader实现了BufRead这个trait，因此在<code>use std::io::BufRead;</code>之后，可以调用这个trait对应的lines()等方法。</p>
<p><a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#impl-BufRead-for-BufReader">https://doc.rust-lang.org/std/io/struct.BufReader.html#impl-BufRead-for-BufReader</a></p>
<p>i)、第22行<code>for line in reader.lines() {</code>lines()函数返回了一个迭代器，然后for line in的方式来遍历这个迭代器，这个迭代器对应的Item为</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>type Item = Result&lt;String, Error&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://doc.rust-lang.org/std/io/struct.Lines.html#associatedtype.Item">https://doc.rust-lang.org/std/io/struct.Lines.html#associatedtype.Item</a></p>
<p>这个被称为trait的Associated type。</p>
<p>j)、这个迭代器的Item是一个Result，因此第23行使用?运算符把其转换成了普通的String;</p>
<p>k)、第24行<code>if line.contains(search_string) {</code>判断line是否包含要搜索的子串；</p>
<p>l)、第25行<code>println!(&quot;{line}&quot;);</code>打印输出，和<code>println!(&quot;{}&quot;, line);</code>等价，前面这种方式被称为named parameters：</p>
<p><a href="https://doc.rust-lang.org/std/fmt/index.html#named-parameters">std::fmt - Rust</a></p>
<p>另外println!包括前面的eprintln!最后的这个!，表示这是一个宏。</p>
<p>Rust中，函数不支持可变参数，通过宏的方式来实现可变参数。</p>
<p>m)、最后第29行，Ok(())这个expression作为整个函数的返回值表示成功。</p>
<p>n)、同时我们注意到search_string和file_path都是&amp;String类型的，run函数的参数&amp;str是什么鬼？</p>
<p>类比于C++中的string和string_view，同时string到string_view可以通过string的operator string_view进行隐式转换：</p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/operator_basic_string_view.html">https://en.cppreference.com/w/cpp/string/basic_string/operator_basic_string_view.html</a></p>
<p>在rust中，String到&amp;str也可以进行隐式转换：</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html#impl-Deref-for-String">https://doc.rust-lang.org/std/string/struct.String.html#impl-Deref-for-String</a></p>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion">Deref in std::ops - Rust</a></p>
<blockquote>
<p>思考题：<br>
1、在上面的30行代码中，一共涉及到哪些trait？<br>
Read、BufRead、Iterator、FromIterator、From、Deref、Termination、Drop<br>
2、在上面的30行代码中，一共有哪些迭代器iterator？<br>
std::env::Args、std::io::Lines</p>
</blockquote>
<p>从上面的这个小例子中，我们也能一窥Rust程序的特点：</p>
<p>1、代码风格，下划线小写命名的形式；</p>
<p>2、倾向于使用trait，使用组合的方式来实现程序的功能；</p>
<p>3、迭代器iterator功能挺强大的；</p>
<p>4、Rust学习曲线确实很陡峭，30行代码竟然涉及这么多语法。</p>
<h3 id="13-rust中组织数据的3种方式">1.3 Rust中组织数据的3种方式</h3>
<p>在Rust中，我们可以使用struct来组织数据。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>struct Person { first_name: String, last_name: String, age: i32, }
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以使用tuple(Rust中的tuple和python中的tuple概念是一致的)：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let person_info = (&#34;Harry&#34;, &#34;Potter&#34;, 18); let first_name = person_info.0; let (first_name, _, _) = person_info;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Rust中的enum表示的可以是一个集合类型中的任意一种：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>enum WebEvent { // An enum variant without any data. PageLoad, // An enum variant with a string slice. KeyPress(char), // An enum variant with a struct. Click { x: i32, y: i32 }, // An enum variant with an owned String. Paste(String), } impl WebEvent { fn describe(&amp;self) { match self { WebEvent::PageLoad =&gt; println!(&#34;Page loaded&#34;), WebEvent::KeyPress(c) =&gt; println!(&#34;Key pressed: {}&#34;, c), WebEvent::Click { x, y } =&gt; println!(&#34;Clicked at: ({}, {})&#34;, x, y), WebEvent::Paste(s) =&gt; println!(&#34;Pasted: {}&#34;, s), } } }
</span></span></code></pre></td></tr></table>
</div>
</div><p>enum通常配合match在一起使用。</p>
<h3 id="14-rust中的ownership">1.4 Rust中的Ownership</h3>
<p>Rust中的ownership规则：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>1. Each value in Rust has an owner. 2. There can only be one owner at a time. 3. When the owner goes out of scope, the value will be dropped.
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过ownership的机制实现RAII，当变量离开作用域的时候，会被释放或者drop掉。</p>
<p>Rust在默认的情况下，是move语义的，比如说：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let a = vec![1, 2, 3]; let b = a; println!(&#34;{:?}&#34;, a); println!(&#34;{:?}&#34;, b); // error[E0382]: borrow of moved value: `a`
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是如果对应的类型实现了Copy这个trait的话，默认就会走copy的语义：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let a = 1; let b = a; println!(&#34;{:?}&#34;, a); println!(&#34;{:?}&#34;, b);
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">https://doc.rust-lang.org/std/marker/trait.Copy.html</a></p>
<p>Rust中为很多简单类型都自动实现了Copy这个trait。</p>
<blockquote>
<p>Copy和Clone的区别：<br>
#[derive(Copy, Clone)]<br>
struct Point {<br>
x: i32,<br>
y: i32,<br>
}</p>
<p>在上面Point的定义中，由于i32同时实现了Copy和Clone这两个trait，因此他们组合在一起，Point也能实现这两个Trait。<br>
#[derive(Clone)]<br>
struct PointList {<br>
points: Vec<Point>,<br>
}</p>
<p>而PointList中，由于Vec只实现了Clone这两个trait，因此PointList也只能实现Clone这个trait，不能实现Copy。<br>
Copy和Clone的区别，就类似于浅拷贝和深拷贝的区别，上面Point的定义，两个变量都是分配在栈上的，浅拷贝和深拷贝没有区别，因此Point可以同时实现Copy和Clone这两个trait；而下面PointList的定义中，Vec在栈上只记录了元信息(pointer, capacity, length)，Vec的元素是存放在堆上的，只能深拷贝，因此只实现了Clone这个trait。</p>
</blockquote>
<h3 id="15-rust中的引用和借用">1.5 Rust中的引用和借用</h3>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>1. At any given time, you can have either one mutable reference or any number of immutable references. 2. References must always be valid.
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于Rust中默认是move语义的，在有的场景下，我并不想转移ownership，这种情况下，可以通过引用来借用。</p>
<p>引用分为两种，一种是immutable引用，一种是mutable的引用。</p>
<p>通过immutable的引用，借用者不能修改；通过mutable的引用，借用者可以对这个变量做任何的修改，比如说赋值、swap等，唯一的一个限制就是要保证这个变量的完整性。</p>
<p>Rust的安全机制要求引用在任何时候都必须有有效；同时，限制mutable引用和immutable引用不能同时存在：你可以有多个immutable的引用；也可以有一个mutable的引用；但是不允许有多个mutable的引用，也不允许mutable的引用和immutable的引用同时存在。</p>
<p>思考：为什么对同一个变量的mutable引用和immutable引用不能同时存在？思考下面的例子：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn main() { let mut v = vec![1, 2, 3, 4]; let first = &amp;v[0]; v.push(5); // error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable println!(&#34;first element: {}&#34;, first); }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="16-trait">1.6 trait</h3>
<p>Rust中的trait类似于golang中的interface，Rust中通过trait定义共同的行为。比如说咱们定义Shape形状这样的trait，所有的形状都有面积：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>trait Shape { fn area(&amp;self) -&gt; f64; }
</span></span></code></pre></td></tr></table>
</div>
</div><p>圆和长方形都能实现Shape形状这个Trait：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>struct Circle { radius: f64, } impl Shape for Circle { fn area(&amp;self) -&gt; f64 { std::f64::consts::PI * self.radius * self.radius } } struct Rectangle { width: f64, height: f64, } impl Shape for Rectangle { fn area(&amp;self) -&gt; f64 { self.width * self.height } }
</span></span></code></pre></td></tr></table>
</div>
</div><p>有了这些定义之后，就可以实现编译时的类型约束：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn print_area1&lt;S: Shape&gt;(shape: &amp;S) { println!(&#34;The area is: {}&#34;, shape.area()); } fn print_area2(shape: &amp;impl Shape) { println!(&#34;The area is: {}&#34;, shape.area()); }
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这两种实现的方式是等价的，impl只是一个语法糖：</p>
<p><a href="https://doc.rust-lang.org/stable/reference/types/impl-trait.html#r-type.impl-trait.param.intro">https://doc.rust-lang.org/stable/reference/types/impl-trait.html</a></p>
<p>也可以实现运行时的多态：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn print_area3(shapes: &amp;[&amp;dyn Shape]) { for shape in shapes { println!(&#34;The area is: {}&#34;, shape.area()); } }
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用上面几个方法的例子：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn main() { let circle = Circle { radius: 5.0 }; let rectangle = Rectangle { width: 10.0, height: 4.0, }; print_area1(&amp;circle); print_area2(&amp;rectangle); let shapes: Vec&lt;&amp;dyn Shape&gt; = vec![&amp;circle, &amp;rectangle]; print_area3(&amp;shapes); }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="17-迭代器">1.7 迭代器</h3>
<p>Rust中的迭代器由Iterator这个trait来表示，表示会产生一个序列的值：</p>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a></p>
<p>这个trait只有一个Required的方法next，当next返回None的时候，表示序列结束：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>// Required method fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以直接调用next方法来一个一个的获取值，但是更多的场景下是使用标准库中提供的adapter和consume方法。</p>
<p>rust中的迭代器有以下特点：</p>
<p>a)、laziness</p>
<p><a href="https://doc.rust-lang.org/std/iter/index.html#laziness">https://doc.rust-lang.org/std/iter/index.html#laziness</a></p>
<p>b)、infinity</p>
<p><a href="https://doc.rust-lang.org/std/iter/index.html#infinity">https://doc.rust-lang.org/std/iter/index.html#infinity</a></p>
<p>c)、高效，性能很高，和手写for循环性能是一致的。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>struct Fibonacci { current: u64, next: u64, } impl Fibonacci { fn new() -&gt; Fibonacci { Fibonacci { current: 0, next: 1 } } } impl Iterator for Fibonacci { type Item = u64; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { let next_number = self.current + self.next; self.current = self.next; self.next = next_number; Some(self.current) } } fn main() { let fib_iterator = Fibonacci::new(); println!(&#34;The first 10 Fibonacci numbers are:&#34;); for number in fib_iterator.take(10) { println!(&#34;{}&#34;, number); } let fib_vec: Vec&lt;u64&gt; = Fibonacci::new().take(15).collect(); println!(&#34;\nThe first 15 numbers collected into a vector:&#34;); println!(&#34;{:?}&#34;, fib_vec); }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="18-闭包">1.8 闭包</h3>
<p>Rust中的闭包能够capture环境中的值，根据capture的方式不同，闭包也分别实现了不同的trait，如果是普通的borrow来capture的话，实现了Fn，如果是mut borrow来capture的话，实现了FnMut，如果是move consume了变量的话，实现FnOnce，看下面的例子：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn main() { let s = String::from(&#34;hello&#34;); let f1 = || &amp;s; println!(&#34;{}&#34;, f1()); println!(&#34;{}&#34;, f1()); }
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上面的代码f1是一个闭包，capture了变量s的引用，编译器自动帮这个闭包实现了Fn的trait，这个闭包可以调用多次。我们也可以看到rust标准库中Fn这个trait的定义是 fn call(&amp;self, args: Args) -&gt; Self::Output;，传递的是self的引用，因此才可以调用多次。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn main() { let mut s = String::from(&#34;hello&#34;); let mut f2 = || s += &#34;world&#34;; f2(); //println!(&#34;{}&#34;, s); f2(); println!(&#34;{}&#34;, s); }
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上面的代码，f2也是一个闭包，mut borrow了s，因此编译器自动帮这个闭包实现了FnMut这个trait，注意，上面的代码中，如果注释掉中间的println!的话，会报<code>error[E0502]: cannot borrow s as immutable because it is also borrowed as mutable</code>错误，f2是变量s的一个mut引用，要满足s引用的限制规则。FnMut在标准库中是这样定义的：<code>fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;</code>，可以看到第一个参数是&amp;mut self。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn main() { let s = String::from(&#34;hello&#34;); let f3 = || s; println!(&#34;{}&#34;, f3()); //println!(&#34;{}&#34;, f3()); // error[E0382]: use of moved value: `f3` }
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码中f3成为了s的owner，实现了FnOnce这个trait，f3只能调用一次，第二次调用的话会报use of moved value的错误信息。FnOnce在标准库中的定义：<code>fn call_once(self, args: Args) -&gt; Self::Output;</code>，self是move的这种调用方式，因此只能调用一次。</p>
<p>同时，编译器为实现了Fn的闭包，也同时实现了FnMut和FnOnce；实现了FnMut的闭包也同时实现了FnOnce。</p>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">https://doc.rust-lang.org/std/ops/trait.Fn.html</a></p>
<p><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">https://doc.rust-lang.org/std/ops/trait.FnMut.html</a></p>
<p><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">https://doc.rust-lang.org/std/ops/trait.FnOnce.html</a></p>
<h3 id="19-sync--send">1.9 Sync &amp; Send</h3>
<p>Rust中的并发安全，是通过Sync和Send这两个trait来体现的。Send表示的含义是，变量可以跨越线程的边界进行传递；Sync表示的含义是，变量可以多线程同时访问。</p>
<p>这里通过一个简单的例子，演示下Sync &amp; Send如何保证并发安全的：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>use std::sync::Arc; use std::sync::Mutex; use std::thread; fn test1() { let mut a = vec![1, 2, 3]; let handler = std::thread::spawn(move || { a.push(4); }); handler.join().unwrap(); } fn test2() { let mut a = vec![1, 2, 3]; thread::scope(|s| { s.spawn(|| { println!(&#34;hello from the first scoped thread&#34;); a.push(4); }); }); a.push(5); } fn test3() { let a1 = Arc::new(vec![1, 2, 3]); let a2 = a1.clone(); let handler = thread::spawn(move || { println!(&#34;a1 {:?}&#34;, a1); }); println!(&#34;a2 {:?}&#34;, a2); handler.join().unwrap(); } fn test4() { let a1 = Arc::new(Mutex::new(vec![1, 2, 3])); let a2 = a1.clone(); let a3 = a1.clone(); let handler1 = thread::spawn(move || { let mut lock_guard = a1.lock().unwrap(); lock_guard.push(4); }); let handler2 = thread::spawn(move || { let mut lock_guard = a2.lock().unwrap(); lock_guard.push(4); }); handler1.join().unwrap(); handler2.join().unwrap(); println!(&#34;a3 {:?}&#34;, a3.lock().unwrap()); } fn main() { test1(); test2(); test3(); test4(); }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="110-async--await">1.10 async &amp; await</h3>
<p>Rust的异步编程，被称为无栈协程，先看一个简单的例子：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>use anyhow::Result; use serde::Deserialize; #[derive(Deserialize, Debug)] struct Joke { joke: String, } #[tokio::main] async fn main() -&gt; Result&lt;()&gt; { let res = reqwest::get(&#34;https://geek-jokes.sameerkumar.website/api?format=json&#34;).await?; let joke = res.json::&lt;Joke&gt;().await?; println!(&#34;{}&#34;, joke.joke); Ok(()) }
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用cargo expand命令，上面的代码，main大概展开成下面的样子：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn main() -&gt; Result&lt;()&gt; { tokio::runtime::Builder::new_multi_thread() .enable_all() .build() .expect(&#34;Failed building the Runtime&#34;) .block_on(async { let res = reqwest::get(&#34;https://geek-jokes.sameerkumar.website/api?format=json&#34;).await?; let joke = res.json::&lt;Joke&gt;().await?; println!(&#34;{}&#34;, joke.joke); Ok(()) }) }
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的代码可以看到，代码中首先构建了一个tokio的runtime，然后block_on在某个async块上进行执行。</p>
<p>async/await把Rust程序分割成了两个世界，在async/await的上下文里，不能调用阻塞的函数，不然会卡住异步运行时tokio的执行和调度。</p>
<p>为了弄清楚async/await到底干了啥，咱们首先看下上面代码中的其中一行代码：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let res = reqwest::get(&#34;https://geek-jokes.sameerkumar.website/api?format=json&#34;).await?;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这行代码可以拆成两行：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let res_future = reqwest::get(&#34;https://geek-jokes.sameerkumar.website/api?format=json&#34;); let res = res_future.await?;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在vscode里面，把鼠标悬停在res_future上，可以看到vscode给出的类型注解是：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let res_future: impl Future&lt;Output = Result&lt;Response, Error&gt;&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到res_future实现了Future这个trait，但是res_future具体的类型不知道，只知道他实现了Future这个trait。</p>
<p>async只是一个语法糖：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>async fn test() { println!(&#34;This is a test function.&#34;); } fn test2() -&gt; impl Future&lt;Output = ()&gt; { async { println!(&#34;This is a test function.&#34;); } }
</span></span></code></pre></td></tr></table>
</div>
</div><p>async的本质，实际上是编译器把<code>reqwest::get(&quot;https://geek-jokes.sameerkumar.website/api?format=json&quot;)</code>编译成了一个状态机，然后这个状态机实现了Future这个trait，所以这里get返回的时候，实际上并没有发出任何http请求，只是返回了一个状态机，这个状态机实现了Future这个trait，仅此而已。理论上来说，也可以手写一个struct，实现同样的状态机，只是这个过程会特别的复杂，编译器直接帮忙咱们做了：</p>
<p><a href="https://doc.rust-lang.org/stable/reference/items/functions.html#r-items.fn.async">https://doc.rust-lang.org/stable/reference/items/functions.html#r-items.fn.async</a></p>
<p>一些手动实现Future的例子：</p>
<p><a href="https://docs.rs/futures-util/latest/futures_util/future/struct.Select.html#impl-Future-for-Select">https://docs.rs/futures-util/latest/futures_util/future/struct.Select.html#impl-Future-for-Select</a></p>
<p><a href="https://docs.rs/tokio/latest/tokio/time/struct.Timeout.html#impl-Future-for-Timeout">https://docs.rs/tokio/latest/tokio/time/struct.Timeout.html#impl-Future-for-Timeout</a></p>
<p>await的本质，实际上是“不停的”调用上面状态机的poll方法，驱动状态机不停的往前走，直到Ready为止。</p>
<p><a href="https://doc.rust-lang.org/stable/reference/expressions/await-expr.html?highlight=await#r-expr.await.effects">https://doc.rust-lang.org/stable/reference/expressions/await-expr.html?highlight=await#r-expr.await.effects</a></p>
<p>rust异步编程的核心，就是Future这个trait：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>pub trait Future { type Output; // Required method fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;) -&gt; Poll&lt;Self::Output&gt;; } pub enum Poll&lt;T&gt; { Ready(T), Pending, }
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面Future这个trait的定义中，poll函数的第一个参数是个<code>Pin&lt;&amp;mut Self&gt;</code>的类型，什么是Pin，为什么需要Pin呢？</p>
<p>还是要从上面async生成的状态机说起，<code>reqwest::get(&quot;https://geek-jokes.sameerkumar.website/api?format=json&quot;)</code>这个函数会返回一个对象，这个对象实现了Future trait，这个对象是一个状态机，内部维护这个请求的执行状态，然后await的时候，会“不停”的poll，驱动状态机往前走，这个状态机内部会维护很多的状态，比如说tcp socket收发的buffer，以及buffer已经使用的大小等。换句话说，这个状态机是一个自引用的对象，状态机内部有一些buffer，然后状态机内部有一些指针指向这些buffer的某些位置等。状态机是自引用的，就要求这个状态机不能在内存中随意的移动，如果移动的话，自引用指针的指向就错了，指向了别的位置。Rust对这个问题的解法就是加一层Pin，对这个状态机的所有的访问，都是通过Pin这个智能指针来访问的，Pin限制了这个状态机不能移动和复制。</p>
<p>异步任务的取消：不.await了，不poll了，异步的请求也就取消了，比如说前面提到的 <a href="https://docs.rs/futures-util/latest/futures_util/future/struct.Select.html#impl-Future-for-Select">https://docs.rs/futures-util/latest/futures_util/future/struct.Select.html</a> 当其中的一个已经Ready之后，另外一个就自动的取消了。</p>
<h3 id="二思维篇">二、思维篇</h3>
<p>每个语言都有自己的特点，比如说Golang推崇通过消息的方式共享内存，Python语言中的list comprehensions是一种强大且简洁的创建列表的方法等，这里介绍下Rust语言的思维方式。</p>
<h3 id="21-expression">2.1 expression</h3>
<p>在Rust中，推崇简洁，表达式可以作为值进行赋值，或者作为返回值：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn foo(x: usize) -&gt; usize { x }
</span></span></code></pre></td></tr></table>
</div>
</div><p>表达式可以赋值：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let x = if 3 &gt; 2 { 1 } else { 2 };
</span></span></code></pre></td></tr></table>
</div>
</div><p>前面的greplite的main函数，也可以写成：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn main() -&gt; io::Result&lt;()&gt; { let mut args = env::args().skip(1); let (search_string, file_path) = match (args.next(), args.next(), args.next()) { (Some(s), Some(f), None) =&gt; (s, f), _ =&gt; { eprintln!(&#34;Usage: greplite &lt;search_string&gt; &lt;file_path&gt;&#34;); std::process::exit(1) } }; run(&amp;search_string, &amp;file_path) }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="22-split">2.2 split</h3>
<p>由于Rust中ownership及引用规则的限制，有些对象会有split的操作，比如说Vec，split成两个，每个只修改Vec的一部分元素，这样整体还是安全的。</p>
<p>再比如说socket，可以split成一个只收数据的socket，一个只发数据的socket，这样可以实现在一个线程中只收数据，在一个线程中只发数据。</p>
<p><a href="https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html#method.into_split">https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html#method.into_split</a></p>
<h3 id="23-无处不在的option和result">2.3 无处不在的Option和Result</h3>
<p>就像在golang中，if err != nil {}和if someData != nil {}无处不在一样，在Rust中，Option和Result也是随处可见；Option和Result都是enum，如果都用match来进行判断的话，代码的递进深度会比较深，另外代码也看起来会很冗余。</p>
<p>为此Rust为Option和Result提供了很多便利的操作。</p>
<p>a)、question mark operator</p>
<p><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#r-expr.try">https://doc.rust-lang.org/reference/expressions/operator-expr.html#r-expr.try</a></p>
<p>b)、is_some()、is_none()、is_ok()、is_err()便捷函数</p>
<p>c)、let else赋值操作</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let a = Some(1); let Some(b) = a else { return; };
</span></span></code></pre></td></tr></table>
</div>
</div><p>d)、和迭代器的互操作等</p>
<p><a href="https://doc.rust-lang.org/std/option/#method-overview">https://doc.rust-lang.org/std/option/#method-overview</a></p>
<p><a href="https://doc.rust-lang.org/std/result/#method-overview">https://doc.rust-lang.org/std/result/#method-overview</a></p>
<p>熟练掌握上面的方法，会让代码更简洁。</p>
<h3 id="24-match的不仅仅是enum">2.4 match的不仅仅是enum</h3>
<p>在Rust中，match通常用来作用在enum上，然后每个分支判断enum的每个变体。</p>
<p>但是match不仅仅可以用在enum上，在其它的场景中，match也能发挥大作用。</p>
<p>另外，match是exhaustive的，需要写出所有的可能的分支。</p>
<p><a href="https://github.com/yaozongyou/rust-24-hour-crash-course/blob/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis/src/connection.rs#L112">https://github.com/yaozongyou/rust-24-hour-crash-course/blob/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis/src/connection.rs#L112</a></p>
<p><a href="https://doc.rust-lang.org/rust-by-example/flow_control/match.html">https://doc.rust-lang.org/rust-by-example/flow_control/match.html</a></p>
<h3 id="25-宏强大的超乎想象">2.5 宏强大的超乎想象</h3>
<p>宏的3种场景：</p>
<p>a)、类似于println!</p>
<p>本质是编译器一些规则的替换</p>
<p><a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html?highlight=hygiene#hygiene">https://doc.rust-lang.org/stable/reference/macros-by-example.html?highlight=hygiene#hygiene</a></p>
<p>b)、类似于前面例子中的<code>#[tokio::main]</code></p>
<p>本质是在编译期，把对应注解的函数的Token Stream给到这个宏，然后这个宏，在编译期生成新的代码。</p>
<p>一个简单这种宏的例子，可以参考下面的这篇文章:</p>
<p><a href="https://zhuanlan.zhihu.com/p/655938360">乐学Rust：100行代码实现简易集成测试框架</a></p>
<p>c)、类似于Debug宏</p>
<p><a href="https://doc.rust-lang.org/std/fmt/derive.Debug.html">https://doc.rust-lang.org/std/fmt/derive.Debug.html</a></p>
<p>本质是在编译期，把对应注解的对应的struct的Token Stream给到这个宏，然后这个宏，在编译期生成新的代码。</p>
<h3 id="26-通过传递消息的方式共享内存">2.6 通过传递消息的方式共享内存</h3>
<p>在Golang中，推崇通过消息的方式共享内存。同样，在Rust中，也支持这种编程的模式。</p>
<p>考虑对象从一个存储桶搬迁到另外的存储桶这种场景：</p>
<p>
        <img class="mx-auto" alt="" src="https://pic3.zhimg.com/v2-52e6db148ec72a8a26734b2252908da4_1440w.jpg" />   
    </p>
<p>一种操作流程的组织形式可能类似于上图，左边的routine，调用list objects的接口，或者从文件列表中获取所有的对象列表，然后再把这些对象，放入到一个channel中；然后右边的copy的routine，具体执行copy每个对象的动作。</p>
<p>list操作和具体的copy操作在流程上做了分离，代码简洁清晰。</p>
<p>上面这个流程有一个小问题就是，当遇到大对象的时候，大对象可能会成为长尾的瓶颈，因为每个对象都是单routine拷贝的。流程上可以优化如下：</p>
<p>
        <img class="mx-auto" alt="" src="https://pica.zhimg.com/v2-e1040f41c5efc42ac699ab13904d0d38_1440w.jpg" />   
    </p>
<p>如上图，再加一层，真正的copy操作只在worker中进行处理，在copy这一层，把每个对象的copy任务，拆分成多个task，如果对象比较小的话，对应一个task，对象比较大的话，采用分块上传的方式，拆分成多个task。上图中的第二个channel里面的消息就是每个task任务，同时每个task任务中会包含另外一个channel，这个worker通过这个channel告知copy的routine对应的task的完成情况。</p>
<p>通知这种流程的组织形式，解决了大对象长尾的问题。流程依然清晰简洁。</p>
<p>在Rust中同样可以实现上面的这种流程模式。</p>
<p>不过对比Rust和Golang中channel和select的体验，由于Rust不是像golang那样，在语言本身支持channel和select，因此体感上，Rust稍微差了一丢丢。</p>
<h3 id="27-和c一致的内存模型">2.7 和C++一致的内存模型</h3>
<p>Rust采用和C++一致的内存模型，都是通过atomic原子操作来体现的，C++上的经验可以直接迁移到Rust上。</p>
<p>比如说，考虑配置热加载的场景，一种可能的实现是这样的，一个atomic的pointer指向当前的配置，然后有一个线程从本地或者通过sdk周期性从外部取最新的配置，然后再atomic的更新pointer指向最新的配置。</p>
<p>这里有个问题是，原来的配置何时释放的问题(safe memory reclamation)，在C++中，通常使用hazard pointer来解决，在Rust中也类似，也有hazard pointer。</p>
<p>不过最新的这种问题的解决方式，建议使用《Concurrent Deferred Reference Counting with Constant-Time Overhead》这篇paper介绍的方法，使用更方便：</p>
<p><a href="https://github.com/cmuparlay/concurrent_deferred_rc">https://github.com/cmuparlay/concurrent_deferred_rc</a></p>
<p>对应Rust的crate:</p>
<p><a href="https://github.com/aarc-rs/aarc">https://github.com/aarc-rs/aarc</a></p>
<p>关于Rust内存模型的书籍推荐。</p>
<p><a href="https://marabos.nl/atomics/">https://marabos.nl/atomics/</a></p>
<h3 id="28-interior-mutability-pattern">2.8 Interior Mutability Pattern</h3>
<p>由于Rust的ownership以及引用规则的限制，在写代码的时候，要想好各种数据结构，是否会跨多线程访问，如果跨多线程访问的话，可能要使用interior mutability pattern，所有的struct的函数都是&amp;self，而不是&amp;mut self。</p>
<p>参考例子：</p>
<p><a href="https://github.com/yaozongyou/rust-24-hour-crash-course/blob/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis/src/store.rs#L45">https://github.com/yaozongyou/rust-24-hour-crash-course/blob/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis/src/store.rs#L45</a></p>
<h3 id="29-buildrs在编译期执行各种操作">2.9 build.rs在编译期执行各种操作</h3>
<p>crate有个build.rs脚本，可以获取代码仓库的git信息，编译c/c++程序等：</p>
<p><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">https://doc.rust-lang.org/cargo/reference/build-scripts.html</a></p>
<p><a href="https://github.com/yaozongyou/rust-24-hour-crash-course/blob/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis/build.rs">https://github.com/yaozongyou/rust-24-hour-crash-course/blob/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis/build.rs</a></p>
<h3 id="210-迭代器真的很好用">2.10 迭代器真的很好用</h3>
<p>在Rust中，适当的使用迭代器会让代码更简洁。各种collection(Vec、HashMap、BTreeMap等)都能通过迭代器来遍历，Result和Option等也都能和迭代器相互转换等，迭代器也有特别多的adapter。</p>
<p>从C++转到Rust的话，可以尝试多使用下迭代器。</p>
<p><a href="https://doc.rust-lang.org/std/iter/">https://doc.rust-lang.org/std/iter/</a></p>
<p>之前greplite程序，可以改下成：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn run(search_string: &amp;str, file_path: &amp;str) -&gt; io::Result&lt;()&gt; { let file = File::open(file_path)?; let reader = BufReader::new(file); reader.lines().try_for_each(|line| { let line = line?; if line.contains(search_string) { println!(&#34;{}&#34;, line); } Ok::&lt;(), _&gt;(()) }) }
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fn run(search_string: &amp;str, file_path: &amp;str) -&gt; io::Result&lt;()&gt; { let file = File::open(file_path)?; let reader = BufReader::new(file); reader .lines() .collect::&lt;io::Result&lt;Vec&lt;_&gt;&gt;&gt;()? .into_iter() .filter(|line| line.contains(search_string)) .for_each(|line| println!(&#34;{}&#34;, line)); Ok(()) }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="211-想定义个全局变量真不容易">2.11 想定义个全局变量真不容易</h3>
<p>关于全局变量，下面这篇文章总结的非常好:</p>
<p><a href="https://www.sitepoint.com/rust-global-variables/">https://www.sitepoint.com/rust-global-variables/</a></p>
<p>
        <img class="mx-auto" alt="" src="https://picx.zhimg.com/v2-469ab569514dd90907b42c5248e15d9d_1440w.jpg" />   
    </p>
<p>另外，上面这篇文章写的比较久了，上图中的lazy_static or once_cell，在当前最新的Rust的版本中，可以使用<a href="https://doc.rust-lang.org/std/sync/struct.OnceLock.html">OnceLock</a> 或者 <a href="https://doc.rust-lang.org/std/sync/struct.LazyLock.html">LazyLock</a>来替代，这样就不需要依赖第三方的crate了。</p>
<h3 id="三实战篇">三、实战篇</h3>
<p>使用Rust实现一个mini-redis：</p>
<p><a href="https://github.com/yaozongyou/rust-24-hour-crash-course/tree/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis">https://github.com/yaozongyou/rust-24-hour-crash-course/tree/bdf5bc30a67fe6b5649a8fff7cc25e2e0d19a0e6/mini-redis</a></p>
<h3 id="rust学习建议">Rust学习建议</h3>
<p>1、The Book通读一遍</p>
<p>2、<a href="https://rustlings.rust-lang.org/">https://rustlings.rust-lang.org/</a></p>
<p>rustlings上面的练习全部走一遍。</p>
<p>3、不要尝试写链表、不要尝试写链表、不要尝试写链表。</p>
<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3">Using lightweight formal methods to validate a key-value storage node in Amazon S3</a></li>
<li><a href="https://rsproxy.cn/">RsProxy</a></li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></li>
<li><a href="https://this-week-in-rust.org/">This Week in Rust</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/intro.html">https://doc.rust-lang.org/nomicon/intro.html</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/introduction.html">https://doc.rust-lang.org/stable/reference/introduction.html</a></li>
<li><a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a></li>
<li><a href="https://rustlings.rust-lang.org/">https://rustlings.rust-lang.org/</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/index.html">https://doc.rust-lang.org/rust-by-example/index.html</a></li>
<li><a href="https://github.com/yaozongyou/rust-24-hour-crash-course">https://github.com/yaozongyou/rust-24-hour-crash-course</a></li>
</ol>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://index.zshipu.com/geek002/">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://index.zshipu.com/geek002/post/202510/24%E5%B0%8F%E6%97%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%A4%A7%E7%83%AD%E8%AF%AD%E8%A8%80Rust-%E7%9F%A5%E4%B9%8E/">https://index.zshipu.com/geek002/post/202510/24%E5%B0%8F%E6%97%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%A4%A7%E7%83%AD%E8%AF%AD%E8%A8%80Rust-%E7%9F%A5%E4%B9%8E/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/geek002/post/202510/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%A7%8D%E8%8D%89%E5%B0%B1%E6%98%AF%E8%AE%A9%E5%86%85%E5%AE%B9%E5%85%B7%E5%A4%87%E8%90%A5%E9%94%80%E5%9F%BA%E5%9B%A0-%E5%A6%82%E4%BD%95%E8%B7%91%E9%80%9A%E5%86%85%E5%AE%B9%E5%88%B0%E7%94%9F%E6%84%8F%E7%9A%84%E8%B7%AF%E5%BE%84/">小红书种草就是让内容具备营销基因，如何跑通内容到生意的路径？</a></li>
        
        <li><a href="/geek002/post/202510/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%88%86%E6%AC%BE%E5%AF%86%E7%A0%81-%E6%98%AF%E4%B8%80%E5%9C%BA%E6%8A%A2%E5%A4%BA%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E7%AB%9E%E8%B5%9B/">小红书爆款密码，是一场抢夺注意力的“竞赛”</a></li>
        
        <li><a href="/geek002/post/202510/%E6%99%AE%E9%80%9A%E4%BA%BA%E5%81%9A%E8%87%AA%E5%AA%92%E4%BD%93%E5%8D%9A%E4%B8%BB%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9F%B9%E5%85%BB%E8%87%AA%E5%B7%B1%E7%9A%84%E6%B5%81%E9%87%8F%E6%80%9D%E7%BB%B4-%E8%AE%A9%E7%88%86%E6%AC%BE%E6%88%90%E4%B8%BA%E5%B8%B8%E6%80%81/">普通人做自媒体博主一定要培养自己的流量思维，让爆款成为常态</a></li>
        
        <li><a href="/geek002/post/202510/%E8%87%AA%E5%AA%92%E4%BD%93%E7%88%86%E6%AC%BE%E5%BA%95%E5%B1%82%E8%B5%B7%E5%8F%B7%E9%80%BB%E8%BE%91-6%E4%B8%AA%E6%89%93%E9%80%A0%E6%B6%A8%E7%B2%89%E7%9A%84%E7%88%86%E6%96%87%E5%A4%8D%E5%88%B6%E6%96%B9%E6%B3%95%E8%AE%BA/">自媒体爆款底层起号逻辑，6个打造涨粉的爆文复制方法论</a></li>
        
        <li><a href="/geek002/post/202510/%E8%BF%99%E6%A0%B7%E5%81%9A%E5%B0%8F%E7%BA%A2%E4%B9%A6-%E6%99%AE%E9%80%9A%E5%8D%9A%E4%B8%BB%E4%B9%9F%E8%83%BD%E5%81%9A%E5%87%BA%E7%88%86%E6%AC%BE/">这样做小红书，普通博主也能做出爆款</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            没有标签
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-index"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2025 <a href="https://index.zshipu.com/geek002/">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/geek002/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://index.zshipu.com/geek002/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://index.zshipu.com/geek002/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%A7%8D%E8%8D%89%E5%B0%B1%E6%98%AF%E8%AE%A9%E5%86%85%E5%AE%B9%E5%85%B7%E5%A4%87%E8%90%A5%E9%94%80%E5%9F%BA%E5%9B%A0-%E5%A6%82%E4%BD%95%E8%B7%91%E9%80%9A%E5%86%85%E5%AE%B9%E5%88%B0%E7%94%9F%E6%84%8F%E7%9A%84%E8%B7%AF%E5%BE%84/" title="小红书种草就是让内容具备营销基因，如何跑通内容到生意的路径？">小红书种草就是让内容具备营销基因，如何跑通内容到生意的路径？</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%88%86%E6%AC%BE%E5%AF%86%E7%A0%81-%E6%98%AF%E4%B8%80%E5%9C%BA%E6%8A%A2%E5%A4%BA%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E7%AB%9E%E8%B5%9B/" title="小红书爆款密码，是一场抢夺注意力的“竞赛”">小红书爆款密码，是一场抢夺注意力的“竞赛”</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E6%99%AE%E9%80%9A%E4%BA%BA%E5%81%9A%E8%87%AA%E5%AA%92%E4%BD%93%E5%8D%9A%E4%B8%BB%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9F%B9%E5%85%BB%E8%87%AA%E5%B7%B1%E7%9A%84%E6%B5%81%E9%87%8F%E6%80%9D%E7%BB%B4-%E8%AE%A9%E7%88%86%E6%AC%BE%E6%88%90%E4%B8%BA%E5%B8%B8%E6%80%81/" title="普通人做自媒体博主一定要培养自己的流量思维，让爆款成为常态">普通人做自媒体博主一定要培养自己的流量思维，让爆款成为常态</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E8%87%AA%E5%AA%92%E4%BD%93%E7%88%86%E6%AC%BE%E5%BA%95%E5%B1%82%E8%B5%B7%E5%8F%B7%E9%80%BB%E8%BE%91-6%E4%B8%AA%E6%89%93%E9%80%A0%E6%B6%A8%E7%B2%89%E7%9A%84%E7%88%86%E6%96%87%E5%A4%8D%E5%88%B6%E6%96%B9%E6%B3%95%E8%AE%BA/" title="自媒体爆款底层起号逻辑，6个打造涨粉的爆文复制方法论">自媒体爆款底层起号逻辑，6个打造涨粉的爆文复制方法论</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E8%BF%99%E6%A0%B7%E5%81%9A%E5%B0%8F%E7%BA%A2%E4%B9%A6-%E6%99%AE%E9%80%9A%E5%8D%9A%E4%B8%BB%E4%B9%9F%E8%83%BD%E5%81%9A%E5%87%BA%E7%88%86%E6%AC%BE/" title="这样做小红书，普通博主也能做出爆款">这样做小红书，普通博主也能做出爆款</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E7%94%A8%E5%85%AB%E5%8D%A6%E6%80%9D%E7%BB%B4%E5%81%9A%E5%B0%8F%E7%BA%A2%E4%B9%A6-%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E7%88%86%E6%AC%BE%E7%AC%94%E8%AE%B0/" title="用“八卦思维”做小红书，轻松写出爆款笔记">用“八卦思维”做小红书，轻松写出爆款笔记</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%88%86%E6%AC%BE%E5%86%85%E5%AE%B9%E6%A0%B8%E5%BF%83%E7%8E%A9%E6%B3%95-%E6%8B%BF%E6%8D%8F%E4%BA%BA%E6%80%A7%E7%9A%84%E6%B5%81%E9%87%8F%E5%AF%86%E7%A0%81%E6%9C%80%E5%A5%BD%E8%B5%9A/" title="小红书爆款内容核心玩法，拿捏人性的流量密码最好赚">小红书爆款内容核心玩法，拿捏人性的流量密码最好赚</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%81%9A%E6%89%8D%E4%BC%9A%E6%9C%89%E6%B5%81%E9%87%8F%E8%AF%A6%E8%A7%A3%E7%88%86%E6%AC%BE%E7%AC%94%E8%AE%B0%E4%BB%8E%E5%B0%81%E9%9D%A2%E5%88%B0%E5%86%85%E5%AE%B9%E7%9A%84%E5%88%9B%E4%BD%9C%E6%8A%80%E5%B7%A7/" title="小红书到底怎么做才会有流量？详解爆款笔记从封面到内容的创作技巧">小红书到底怎么做才会有流量？详解爆款笔记从封面到内容的创作技巧</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E5%81%9A%E8%87%AA%E5%AA%92%E4%BD%93%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E8%B5%9B%E9%81%93%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%B5%9B%E9%81%93%E8%88%92%E9%80%82%E5%8C%BA-%E8%AE%A9%E5%81%9A%E5%8D%9A%E4%B8%BB%E4%BA%8B%E5%8D%8A%E5%8A%9F%E5%80%8D/" title="做自媒体怎么选择赛道？如何定位赛道舒适区，让做博主事半功倍">做自媒体怎么选择赛道？如何定位赛道舒适区，让做博主事半功倍</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/geek002/post/202510/%E6%83%85%E7%BB%AA%E8%83%8C%E5%90%8E%E7%9A%84%E9%9C%80%E6%B1%82%E7%BB%8F%E6%B5%8E-2025%E8%A6%81%E6%88%90%E4%B8%BA%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%83%AD%E9%97%A8%E8%B5%9B%E9%81%93%E9%AB%98%E6%83%85%E7%BB%AA%E4%BB%B7%E5%80%BC%E7%9A%84%E6%83%85%E6%84%9F%E7%96%97%E6%84%88%E5%8D%9A%E4%B8%BB/" title="情绪背后的需求经济：2025要成为小红书热门赛道高情绪价值的情感疗愈博主">情绪背后的需求经济：2025要成为小红书热门赛道高情绪价值的情感疗愈博主</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title"><a href='/geek002/categories/'>分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/geek002/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://index.zshipu.com/geek002/tags/2.32/">2.32</a>
    
    <a href="https://index.zshipu.com/geek002/tags/6G%E6%98%BE%E5%AD%98/">6G显存</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Agentic-RAG/">Agentic RAG</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI/">AI</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI-Agent/">AI Agent</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI%E4%BB%A3%E7%A0%81%E5%8A%A9%E6%89%8B/">AI代码助手</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/">AI代码编辑器</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI%E5%8A%A9%E6%89%8B/">AI助手</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI%E6%8A%80%E6%9C%AF/">AI技术</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI%E8%AF%AD%E9%9F%B3/">AI语音</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AI%E9%A9%B1%E5%8A%A8/">AI驱动</a>
    
    <a href="https://index.zshipu.com/geek002/tags/API/">API</a>
    
    <a href="https://index.zshipu.com/geek002/tags/APP%E5%BC%B9%E7%AA%97%E8%AE%BE%E8%AE%A1/">APP弹窗设计</a>
    
    <a href="https://index.zshipu.com/geek002/tags/AutoProxyCreator/">AutoProxyCreator</a>
    
    <a href="https://index.zshipu.com/geek002/tags/BAAIbge-m3/">BAAIbge-M3</a>
    
    <a href="https://index.zshipu.com/geek002/tags/BeanFactory/">BeanFactory</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Bean%E6%B3%A8%E5%85%A5/">Bean注入</a>
    
    <a href="https://index.zshipu.com/geek002/tags/BGE-M3/">BGE-M3</a>
    
    <a href="https://index.zshipu.com/geek002/tags/bge-reranker-v2-m3/">Bge-Reranker-V2-M3</a>
    
    <a href="https://index.zshipu.com/geek002/tags/B%E7%AB%AF%E4%BD%93%E9%AA%8C/">B端体验</a>
    
    <a href="https://index.zshipu.com/geek002/tags/CentOS/">CentOS</a>
    
    <a href="https://index.zshipu.com/geek002/tags/CentOS-7/">CentOS 7</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Centos8/">Centos8</a>
    
    <a href="https://index.zshipu.com/geek002/tags/chatchat/">Chatchat</a>
    
    <a href="https://index.zshipu.com/geek002/tags/ChatGPT/">ChatGPT</a>
    
    <a href="https://index.zshipu.com/geek002/tags/chattts/">Chattts</a>
    
    <a href="https://index.zshipu.com/geek002/tags/ClickHouse/">ClickHouse</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Conan-Embedding/">Conan-Embedding</a>
    
    <a href="https://index.zshipu.com/geek002/tags/CSDN%E5%8D%9A%E5%AE%A2/">CSDN博客</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Cursor-IDE/">Cursor IDE</a>
    
    <a href="https://index.zshipu.com/geek002/tags/DEV%E7%A4%BE%E5%8C%BA/">DEV社区</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Dify/">Dify</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Docker/">Docker</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Edge-TTS/">Edge-TTS</a>
    
    <a href="https://index.zshipu.com/geek002/tags/fastgpt/">Fastgpt</a>
    
    <a href="https://index.zshipu.com/geek002/tags/FastgptDify/">FastgptDify</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Gemini/">Gemini</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Glibc/">Glibc</a>
    
    <a href="https://index.zshipu.com/geek002/tags/GPT%E7%BC%96%E7%A8%8B/">GPT编程</a>
    
    <a href="https://index.zshipu.com/geek002/tags/GPU/">GPU</a>
    
    <a href="https://index.zshipu.com/geek002/tags/GPU%E9%83%A8%E7%BD%B2/">GPU部署</a>
    
    <a href="https://index.zshipu.com/geek002/tags/HTTP%E4%BB%A3%E7%90%86/">HTTP代理</a>
    
    <a href="https://index.zshipu.com/geek002/tags/IoC/">IoC</a>
    
    <a href="https://index.zshipu.com/geek002/tags/IoC%E5%AE%B9%E5%99%A8/">IoC容器</a>
    
    <a href="https://index.zshipu.com/geek002/tags/iOS/">IOS</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Java/">Java</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Java%E7%BC%96%E7%A8%8B/">Java编程</a>
    
    <a href="https://index.zshipu.com/geek002/tags/JDBC/">JDBC</a>
    
    <a href="https://index.zshipu.com/geek002/tags/JdbcTemplate/">JdbcTemplate</a>
    
    <a href="https://index.zshipu.com/geek002/tags/langchain/">Langchain</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Linux/">Linux</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Milvus/">Milvus</a>
    
    <a href="https://index.zshipu.com/geek002/tags/MinerU/">MinerU</a>
    
    <a href="https://index.zshipu.com/geek002/tags/ModelAndView/">ModelAndView</a>
    
    <a href="https://index.zshipu.com/geek002/tags/MVC/">MVC</a>
    
    <a href="https://index.zshipu.com/geek002/tags/MyBatis/">MyBatis</a>
    
    <a href="https://index.zshipu.com/geek002/tags/NVIDIA/">NVIDIA</a>
    
    <a href="https://index.zshipu.com/geek002/tags/OCR%E8%AF%86%E5%88%AB/">OCR识别</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Ollama/">Ollama</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Open-WebUI/">Open WebUI</a>
    
    <a href="https://index.zshipu.com/geek002/tags/OpenAI-API/">OpenAI API</a>
    
    <a href="https://index.zshipu.com/geek002/tags/OpenSSL/">OpenSSL</a>
    
    <a href="https://index.zshipu.com/geek002/tags/ORM%E6%A1%86%E6%9E%B6/">ORM框架</a>
    
    <a href="https://index.zshipu.com/geek002/tags/PDF%E5%A4%84%E7%90%86/">PDF处理</a>
    
    <a href="https://index.zshipu.com/geek002/tags/PDF%E8%A7%A3%E6%9E%90/">PDF解析</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Pointcut/">Pointcut</a>
    
    <a href="https://index.zshipu.com/geek002/tags/PowerShell/">PowerShell</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Python/">Python</a>
    
    <a href="https://index.zshipu.com/geek002/tags/PyTorch/">PyTorch</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Qwen2.5/">Qwen2.5</a>
    
    <a href="https://index.zshipu.com/geek002/tags/RAG/">RAG</a>
    
    <a href="https://index.zshipu.com/geek002/tags/RAG%E7%B3%BB%E7%BB%9F/">RAG系统</a>
    
    <a href="https://index.zshipu.com/geek002/tags/SDK/">SDK</a>
    
    <a href="https://index.zshipu.com/geek002/tags/SDK%E9%9B%86%E6%88%90/">SDK集成</a>
    
    <a href="https://index.zshipu.com/geek002/tags/SEO/">SEO</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Servlet/">Servlet</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Spring/">Spring</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Spring-AOP/">Spring AOP</a>
    
    <a href="https://index.zshipu.com/geek002/tags/SpringMVC/">SpringMVC</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Spring%E6%A1%86%E6%9E%B6/">Spring框架</a>
    
    <a href="https://index.zshipu.com/geek002/tags/SQL%E8%AF%AD%E5%8F%A5/">SQL语句</a>
    
    <a href="https://index.zshipu.com/geek002/tags/t3.gg/">T3.gg</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Text2SQL/">Text2SQL</a>
    
    <a href="https://index.zshipu.com/geek002/tags/urllib3/">Urllib3</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Web-Chat/">Web Chat</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Web%E7%8E%AF%E5%A2%83/">Web环境</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Windsurf/">Windsurf</a>
    
    <a href="https://index.zshipu.com/geek002/tags/Xinference/">Xinference</a>
    
    <a href="https://index.zshipu.com/geek002/tags/YUM-%E6%BA%90/">YUM 源</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%B8%93%E9%97%A8%E4%BB%BB%E5%8A%A1/">专门任务</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%B8%AD%E6%96%87Embedding/">中文Embedding</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D/">产品定位</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BA%AC%E4%B8%9C/">京东</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/">人人都是产品经理</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95/">代理方法</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BB%B7%E5%80%BC%E9%87%8D%E5%A1%91/">价值重塑</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/">任务分配</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BC%81%E4%B8%9A%E6%9E%B6%E6%9E%84/">企业架构</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/">依赖注入</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/">信息检索</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%81%A5%E5%BA%B7/">健康</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%81%A5%E5%BA%B7%E7%A4%BE%E5%8C%BA/">健康社区</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%81%A5%E5%BA%B7%E7%BD%91%E7%AB%99/">健康网站</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/">初始化方法</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%89%8D%E7%AB%AF%E5%B1%95%E7%A4%BA/">前端展示</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">动态代理</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%8F%82%E6%95%B0/">参数</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/">商业模式</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%9B%9E%E9%A1%BE/">回顾</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/">国内镜像</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%9B%BD%E5%A4%96/">国外</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/">在线工具</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%9F%8B%E7%82%B9%E9%87%87%E9%9B%86/">埋点采集</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%A4%9A%E6%80%81/">多态</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%A4%9A%E6%96%87%E6%A1%A3RAG/">多文档RAG</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/">大型语言模型</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/">大模型</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%89%E5%85%A8%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/">安全聊天机器人</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%89%E8%A3%85/">安装</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/">安装指南</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%9A%E5%88%B6%E5%8C%96/">定制化</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%9E%E7%8E%B0/">实现</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/">实现方法</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/">实用指南</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%B9%E5%99%A8/">容器</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6/">容器事件</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%AE%B9%E5%99%A8%E5%B7%A5%E5%85%B7%E5%8C%85/">容器工具包</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/">属性配置</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%B7%A5%E5%85%B7/">工具</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%B7%A5%E5%8E%82%E4%BD%93%E7%B3%BB/">工厂体系</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">底层原理</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%BC%80%E6%BA%90/">开源</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/">开源工具</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">循环依赖</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%89%B9%E9%87%8F%E5%8C%B9%E9%85%8D/">批量匹配</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/">拦截器</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%8E%92%E5%90%8D/">排名</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%8E%92%E8%A1%8C%E6%A6%9C/">排行榜</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%8F%92%E5%85%A5%E9%80%BB%E8%BE%91/">插入逻辑</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/">效率提升</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B/">数字化转型</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/">数据传递</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">数据处理</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/">数据库操作</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB/">数据库隔离</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/">数据绑定</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%96%87%E6%9C%AC%E5%88%B0%E8%AF%AD%E9%9F%B3/">文本到语音</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%96%87%E6%9C%AC%E6%8F%90%E5%8F%96/">文本提取</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E/">方法前后</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%97%A0%E4%BE%B5%E5%85%A5/">无侵入</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%99%BA%E8%83%BD%E4%B8%AD%E5%BF%83/">智能中心</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%99%BA%E8%83%BD%E4%BD%93/">智能体</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%99%BA%E8%83%BD%E5%8A%A9%E6%89%8B/">智能助手</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%99%BA%E8%83%BD%E6%96%B9%E6%A1%88/">智能方案</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%99%BA%E8%83%BD%E8%81%8A%E5%A4%A9/">智能聊天</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%86%85%E5%AD%98/">服务器集群内存</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%9C%9F%E6%9C%AB%E6%B5%8B%E8%AF%95/">期末测试</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">构造函数</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA/">检索增强</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/">模块化</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%A8%A1%E5%9E%8B/">模型</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%A8%A1%E6%9D%BF/">模板</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%A8%A1%E6%9D%BF%E6%8A%BD%E5%8F%96/">模板抽取</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%AF%AB%E7%A7%92%E7%BA%A7%E6%8E%A8%E9%80%81/">毫秒级推送</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%B3%A8%E8%A7%A3/">注解</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E6%BB%A1%E5%88%86/">满分</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/">热点数据</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/">环境变量</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/">生产环境</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%94%9F%E6%88%90%E5%BC%8FAI/">生成式AI</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA/">用户行为</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%99%BE%E4%BA%BF%E7%BA%A7%E5%95%86%E4%B8%9A%E7%94%9F%E6%80%81/">百亿级商业生态</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%9F%A5%E8%AF%86/">知识</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%9F%A5%E8%AF%86%E4%BC%A0%E6%89%BF/">知识传承</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/">知识分享</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%84%E5%BB%BA/">知识库构建</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%9F%A5%E8%AF%86%E9%93%BA/">知识铺</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B3%BB%E7%BB%9F/">第三方系统</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%B2%BE%E7%A1%AE/">精确</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7/">系统稳定性</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">系统解决方案</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/">组件化</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BC%96%E7%A0%81%E4%BD%93%E9%AA%8C/">编码体验</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BC%96%E7%A8%8B%E7%BC%96%E8%BE%91%E5%99%A8/">编程编辑器</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BC%96%E7%A8%8B%E8%BE%85%E5%8A%A9/">编程辅助</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BC%96%E8%BE%91%E5%99%A8/">编辑器</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BD%91%E7%AB%99/">网站</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E7%BD%91%E7%AB%99%E5%88%86%E6%9E%90/">网站分析</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%80%81%E5%85%B5/">老兵</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/">脚本文件</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2/">自动转换</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/">论文写作</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97/">设计指南</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/">语言处理</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/">语音合成</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%AF%B7%E6%B1%82%E5%88%86%E6%B4%BE/">请求分派</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/">软件应用</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/">软件架构</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E8%BF%90%E8%A1%8C%E6%97%B6/">运行时</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%83%A8%E4%BB%B6%E6%8A%BD%E5%8F%96/">部件抽取</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%83%A8%E7%BD%B2/">部署</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%85%8D%E7%BD%AE%E5%8C%96/">配置化</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%87%8F%E5%8C%96/">量化</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%94%99%E8%AF%AF%E8%AF%86%E5%88%AB/">错误识别</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%9B%B6%E7%BC%96%E7%A0%81/">零编码</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/">面向切面编程</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象编程</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%A1%B5%E9%9D%A2%E5%81%9C%E7%95%99%E6%97%B6%E9%95%BF/">页面停留时长</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">领域驱动设计</a>
    
    <a href="https://index.zshipu.com/geek002/tags/%E9%AB%98%E9%A2%91%E9%95%9C/">高频镜</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://index.zshipu.com/geek002/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>