<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 知识铺的博客</title>
    <link>https://index.zshipu.com/go/tags/go/</link>
    <description>Recent content in Go on 知识铺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 11 Feb 2021 16:13:20 +0800</lastBuildDate>
    <atom:link href="https://index.zshipu.com/go/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go1.16 新特性：详解内存管理机制的变更，你需要了解</title>
      <link>https://index.zshipu.com/go/posts/go/go1.16-3/</link>
      <pubDate>Thu, 11 Feb 2021 16:13:20 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go1.16-3/</guid>
      <description>大家好，我是正在学习如何蒸鱼的知识铺。 在前面 Go1.16 特性介绍的文章中我们有提到，从 v1.16 起，Go 在 Linux 下的默认内存管理策略会从MADV_FREE 改回 MADV_DONTNEED 策略。 这时候可能至少分两拨小伙伴，分别是： 知道是什么，被这个问题 “折磨“ 过的，瞬间眼前一亮。 不知道是什么，出现了各种疑惑了，这说的都是些什么。</description>
    </item>
    <item>
      <title>Go1.16 新特性：快速上手 Go embed</title>
      <link>https://index.zshipu.com/go/posts/go/go1.16-2/</link>
      <pubDate>Thu, 11 Feb 2021 16:13:19 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go1.16-2/</guid>
      <description>在以前，很多从其他语言转过来 Go 语言的同学会问到，或是踩到一个坑。就是以为 Go 语言所打包的二进制文件中会包含配置文件的联同编译和打包。 结果往往一把二进制文件挪来挪去，就无法把应用程序运行起来了。因为无法读取到静态文件的资源。 无法将静态资源编译打包进二进制文件的话，通常会有两种解决方法</description>
    </item>
    <item>
      <title>Go1.16 即将正式发布，以下变更你需要知道</title>
      <link>https://index.zshipu.com/go/posts/go/go1.16-1/</link>
      <pubDate>Thu, 11 Feb 2021 16:13:15 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go1.16-1/</guid>
      <description>大家好，我是正在努力学习的知识铺。 在前几天，Go1.16rc1 抢先发布了。结合常规的 28 发布规律，其将会在 2021.02 月份左右发布正式版本。 这次 Go1.16 也带来了一些新特性或变更。那么作为一个 Gopher，想必不能错过这次的更新。 今天这篇文章将会带大家了解一下 Go1.16 的几个需要关注的特性。 废弃 io/ioutil Go 官方认为</description>
    </item>
    <item>
      <title>Go 错误处理：用 panic 取代 err != nil 的模式</title>
      <link>https://index.zshipu.com/go/posts/go/go-error2panic/</link>
      <pubDate>Sat, 12 Dec 2020 17:21:42 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go-error2panic/</guid>
      <description>前段时间我分享了文章 《先睹为快，Go2 Error 的挣扎之路》后，和一位朋友进行了一次深度交流，他给我分享了他们项目组对于 Go 错误处理的方式调整。 简单来讲，就是在业务代码中使用 panic 的方式来替代 “永无止境” 的 if err != nil。这就是今天本文的重点内容，我们一起来看看是怎么做，又有什么优缺点。 为什么想</description>
    </item>
    <item>
      <title>Go 并发：一些有趣的现象和要避开的 “坑”</title>
      <link>https://index.zshipu.com/go/posts/go/go-concurrent-lock/</link>
      <pubDate>Thu, 10 Dec 2020 00:25:59 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go-concurrent-lock/</guid>
      <description>大家好，我是知识铺。 最近在看 Go 并发相关的内容，发现还是有不少细节容易让人迷迷糊糊的，一个不小心就踏入深坑里，且指不定要在上线跑了一些数据后才能发现，那可真是太人崩溃了。 今天来分享几个案例，希望大家在编码时能够避开这几个 “坑”。 案例一 演示代码 第一个案例来自 @鸟窝 大佬在极客时间的分享</description>
    </item>
    <item>
      <title>先睹为快，Go2 Error 的挣扎之路</title>
      <link>https://index.zshipu.com/go/posts/go/go2-errors/</link>
      <pubDate>Thu, 03 Dec 2020 20:56:47 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go2-errors/</guid>
      <description>大家好，我是知识铺。 自从 Go 语言在国内火热以来，除去泛型，其次最具槽点的就是 Go 对错误的处理方式，一句经典的 if err != nil 暗号就能认出你是一个 Go 语言爱好者。 自然，大家对 Go error 的关注度更是高涨，Go team 也是，因此在 Go 2 Draft Designs 中正式提到了 error handling（错误处理）的相关草案，希望能够在未来正式的</description>
    </item>
    <item>
      <title>重磅：Go errors 将不会有任何进一步的改进计划</title>
      <link>https://index.zshipu.com/go/posts/go/gophercon2020-errors/</link>
      <pubDate>Sat, 14 Nov 2020 16:48:33 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gophercon2020-errors/</guid>
      <description>今天在 Gophercon2020 上，Go 1.13 错误提案的作者事后提及他对目前错误格式化的缺失表示遗憾，而且在未来很长的好几年内都不会有任何进一步改进计划。 对此他本人给出的原因之一是：对于错误处理这一领域特定的问题，在他的能力范围内实在是无法给出一个令所有人都满意的方案。 尽管如此，在他演讲的最后，还是给出了一</description>
    </item>
    <item>
      <title>为什么 Go 的泛型一拖再拖？</title>
      <link>https://index.zshipu.com/go/posts/go/go16-preview/</link>
      <pubDate>Thu, 12 Nov 2020 23:47:16 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go16-preview/</guid>
      <description>大家好，我是知识铺。前段时间 Go 语言的泛型讨论频频出现在各微信群，且又冲上了国内外各大文章的 “头条”： 信息汇总来看，Go 泛型这几年会出，但大体来讲现在 Go 泛型又又又推迟了，好家伙。我最早了解到时是考虑 Go1.16 释出，后面又推到了 Go1.17，接着现在又延期到了 Go1.18 了（2021 年底）。 看到了信息</description>
    </item>
    <item>
      <title>Go 语言今年 11 岁，何去何从，现状到底如何？</title>
      <link>https://index.zshipu.com/go/posts/go/go11/</link>
      <pubDate>Wed, 11 Nov 2020 21:21:58 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go11/</guid>
      <description>不说不知道，一说下一跳。Go 语言已经开源 11 周年了，感觉是一路高歌，Release History （polarisxu 整理）如下： 2011 年 3 月 16 日，Go 语言的第一个稳定版本 r56 发布； 2012 年 3 月 28 日，Go 语言的第一个正式版本 Go1 发布，并承诺 1.x 的 兼容性； 2013 年 5 月 13 日，Go1.1 正式版才发布。 2013 年 12 月 1 日，Go</description>
    </item>
    <item>
      <title>解密 Go 语言之反射 reflect</title>
      <link>https://index.zshipu.com/go/posts/go/reflect/</link>
      <pubDate>Sat, 07 Nov 2020 15:01:51 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/reflect/</guid>
      <description>大家好，我是知识铺。 在所有的语言中，反射这一功能基本属于必不可少的模块。虽说 “反射” 这个词让人根深蒂固，但更多的还是 WHY。反射到底是什么，反射又是基于什么法则实现的？ 今天我们通过这篇文章来一一揭晓，以 Go 语言为例，了解反射到底为何物，其底层又是如何实现的。 反射是什么 在计算机学中，</description>
    </item>
    <item>
      <title>Go 应用程序是怎么运行起来的？</title>
      <link>https://index.zshipu.com/go/posts/go/go-bootstrap/</link>
      <pubDate>Thu, 08 Oct 2020 15:57:18 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go-bootstrap/</guid>
      <description>自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然： import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;hello world.&amp;#34;) } 这段程序的输出结果为 hello world.，就是这么的简单又直接。但这时候又不禁思考了起来，这个 hello world. 是怎么输出来，经历了什么过程。 真是非常的好奇，今天我们就通过这篇文章来一探究竟。 引导阶段 查找入口 开始剖析之路，首先编译上文提</description>
    </item>
    <item>
      <title>为什么容器内存占用居高不下，频频 OOM（续）</title>
      <link>https://index.zshipu.com/go/posts/news/why-container-memory-exceed2/</link>
      <pubDate>Fri, 19 Jun 2020 21:29:08 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/news/why-container-memory-exceed2/</guid>
      <description>在上周的文章《为什么容器内存占用居高不下，频频 OOM》 中，我根据现状进行了分析和说明，收到了很多读者的建议和疑惑，因此有了这一篇文章，包含更进一步的说明和排查。 疑问 一般系统内存过高的情况下，可以通过 free -m 查看当前系统的内存使用情况： 在发现是系统内存占用高后，就会有读者会提到，为什么</description>
    </item>
    <item>
      <title>为什么容器内存占用居高不下，频频 OOM</title>
      <link>https://index.zshipu.com/go/posts/news/why-container-memory-exceed/</link>
      <pubDate>Sun, 07 Jun 2020 14:52:19 +0800</pubDate>
      <guid>https://index.zshipu.com/go/posts/news/why-container-memory-exceed/</guid>
      <description>最近我在回顾思考（写 PPT），整理了现状，发现了这个问题存在多时，经过一番波折，最终确定了元凶和相对可行的解决方案，因此也在这里分享一下排查历程。 时间线： 在上 Kubernetes 的前半年，只是用 Kubernetes，开发没有权限，业务服务极少，忙着写新业务，风平浪静。 在上 Kubernetes 的后半年，业务服务较少，</description>
    </item>
    <item>
      <title>Go Modules 终极入门</title>
      <link>https://index.zshipu.com/go/posts/go/go-moduels/2020-02-28-go-modules/</link>
      <pubDate>Fri, 28 Feb 2020 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go-moduels/2020-02-28-go-modules/</guid>
      <description>Go modules 是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。 而 Go1.14，在近期也终于正式发布，Go 官方亲自</description>
    </item>
    <item>
      <title>干货满满的 Go Modules 和 goproxy.cn</title>
      <link>https://index.zshipu.com/go/posts/go/go-moduels/2019-09-29-goproxy-cn/</link>
      <pubDate>Sun, 29 Sep 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/go-moduels/2019-09-29-goproxy-cn/</guid>
      <description>大家好，我是一只普通的知识铺，周四晚上很有幸邀请到 goproxy.cn 的作者 @盛傲飞（@aofei） 到 Go 夜读给我们进行第 61 期 《Go Modules、Go Module Proxy 和 goproxy.cn》的技术分享。 本次 @盛傲飞 的夜读分享，是对 Go Modules 的一次很好的解读，比较贴近工程实践，我必然希望把这块的知识更多的分享给大家，</description>
    </item>
    <item>
      <title>Go 应用内存占用太多，让排查？（VSZ篇）</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-09-24-why-vsz-large/</link>
      <pubDate>Tue, 24 Sep 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-09-24-why-vsz-large/</guid>
      <description>前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。我们大为震惊，赶紧查看监控+报警系统和性能分析，发现应用指标压根就不高，不像有泄露的样子。 那么问题是出在哪里了呢，我们进入某个容器里查看了 top 的系统指标，结果如下：</description>
    </item>
    <item>
      <title>Go1.13 defer 的性能是如何提高的</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-09-07-go1.13-defer/</link>
      <pubDate>Sat, 07 Sep 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-09-07-go1.13-defer/</guid>
      <description>最近 Go1.13 终于发布了，其中一个值得关注的特性就是 defer 在大部分的场景下性能提升了30%，但是官方并没有具体写是怎么提升的，这让大家非常的疑惑。而我因为之前写过《深入理解 Go defer》 和 《Go defer 会有性能损耗，尽量不要用？》 这类文章，因此我挺感兴趣它是做了什么改变才能得到这样子的结果，所以今</description>
    </item>
    <item>
      <title>用 GODEBUG 看 GC</title>
      <link>https://index.zshipu.com/go/posts/go/tools/2019-09-02-godebug-gc/</link>
      <pubDate>Mon, 02 Sep 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/tools/2019-09-02-godebug-gc/</guid>
      <description>什么是 GC 在计算机科学中，垃圾回收（GC）是一种自动管理内存的机制，垃圾回收器会去尝试回收程序不再使用的对象及其占用的内存。而最早 John McCarthy 在 1959 年左右发明了垃圾回收，以简化 Lisp 中的手动内存管理的机制（来自 wikipedia）。 为什么要 GC 手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接</description>
    </item>
    <item>
      <title>用 GODEBUG 看调度跟踪</title>
      <link>https://index.zshipu.com/go/posts/go/tools/2019-08-19-godebug-sched/</link>
      <pubDate>Mon, 19 Aug 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/tools/2019-08-19-godebug-sched/</guid>
      <description>让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或垃圾回收等详细信息，并且还不需要加装其它的插件，非常方便，今天我们将先讲解 GODEBUG 的调度器相关内容，希望对你有所帮助。 不过在开始前，没接触过的小伙伴得</description>
    </item>
    <item>
      <title>Go 大杀器之跟踪剖析 trace</title>
      <link>https://index.zshipu.com/go/posts/go/tools/2019-07-12-go-tool-trace/</link>
      <pubDate>Fri, 12 Jul 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/tools/2019-07-12-go-tool-trace/</guid>
      <description>在 Go 中有许许多多的分析工具，在之前我有写过一篇 《Golang 大杀器之性能剖析 PProf》 来介绍 PProf，如果有小伙伴感兴趣可以去我博客看看。 但单单使用 PProf 有时候不一定足够完整，因为在真实的程序中还包含许多的隐藏动作，例如 Goroutine 在执行时会做哪些操作？执行/阻塞了多长时间？在什么时候阻止</description>
    </item>
    <item>
      <title>从实践到原理，带你参透 gRPC</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-06-29-talking-grpc/</link>
      <pubDate>Sat, 29 Jun 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-06-29-talking-grpc/</guid>
      <description>gRPC 在 Go 语言中大放异彩，越来越多的小伙伴在使用，最近也在公司安利了一波，希望这一篇文章能带你一览 gRPC 的巧妙之处，本文篇幅比较长，请做好阅读准备。本文目录如下： 简述 gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支</description>
    </item>
    <item>
      <title>「连载四」gRPC&#43;gRPC Gateway 能不能不用证书？</title>
      <link>https://index.zshipu.com/go/posts/go/grpc-gateway/2019-06-22-grpc-gateway-tls/</link>
      <pubDate>Sat, 22 Jun 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc-gateway/2019-06-22-grpc-gateway-tls/</guid>
      <description>如果你以前有涉猎过 gRPC+gRPC Gateway 这两个组件，你肯定会遇到这个问题，就是 “为什么非得开 TLS，才能够实现同端口双流量，能不能不开？” 又或是 “我不想用证书就实现这些功能，行不行？”。我被无数的人问过无数次这些问题，也说服过很多人，但说服归说服，不代表放弃。前年不行，不代表今年不行，在今天我希望</description>
    </item>
    <item>
      <title>Go1.12 defer 会有性能损耗，尽量不要用？</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-06-16-defer-loss/</link>
      <pubDate>Sun, 16 Jun 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-06-16-defer-loss/</guid>
      <description>上个月在 @polaris @轩脉刃 的全栈技术群里看到一个小伙伴问 “说 defer 在栈退出时执行，会有性能损耗，尽量不要用，这个怎么解？”。 恰好前段时间写了一篇 《深入理解 Go defer》 去详细剖析 defer 关键字。那么这一次简单结合前文对这个问题进行探讨一波，希望对你有所帮助，但在此之前希望你花几分钟，自己思考一下答</description>
    </item>
    <item>
      <title>深入理解 Go defer</title>
      <link>https://index.zshipu.com/go/posts/go/defer/2019-05-27-defer/</link>
      <pubDate>Mon, 27 May 2019 12:30:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/defer/2019-05-27-defer/</guid>
      <description>在上一章节 《深入理解 Go panic and recover》中，我们发现了 defer 与其关联性极大，还是觉得非常有必要深入一下。希望通过本章节大家可以对 defer 关键字有一个深刻的理解，那么我们开始吧。你先等等，请排好队，我们这儿采取后进先出 LIFO 的出站方式&amp;hellip; 特性 我们简单的过一下 defer 关键字的基础使用，让大</description>
    </item>
    <item>
      <title>深入理解 Go panic and recover</title>
      <link>https://index.zshipu.com/go/posts/go/panic/2019-05-21-panic-and-recover/</link>
      <pubDate>Tue, 21 May 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/panic/2019-05-21-panic-and-recover/</guid>
      <description>作为一个 gophper，我相信你对于 panic 和 recover 肯定不陌生，但是你有没有想过。当我们执行了这两条语句之后。底层到底发生了什么事呢？前几天和同事刚好聊到相关的话题，发现其实大家对这块理解还是比较模糊的。希望这篇文章能够从更深入的角度告诉你为什么，它到底做了什么事？ 思考 一、为什么会中止运行</description>
    </item>
    <item>
      <title>我要在栈上。不，你应该在堆上</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-05-20-stack-heap/</link>
      <pubDate>Mon, 20 May 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-05-20-stack-heap/</guid>
      <description>我们在写代码的时候，有时候会想这个变量到底分配到哪里了？这时候可能会有人说，在栈上，在堆上。信我准没错&amp;hellip; 但从结果上来讲你还是一知半解，这可不行，万一被人懵了呢。今天我们一起来深挖下 Go 在这块的奥妙，自己动手丰衣足食 问题 1 2 3 4 5 6 7 8 9 10 11 12 13 type User struct { ID int64 Name string Avatar string } func</description>
    </item>
    <item>
      <title>为什么遍历 Go map 是无序的</title>
      <link>https://index.zshipu.com/go/posts/go/map/2019-04-07-why-map-no-order/</link>
      <pubDate>Sun, 07 Apr 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/map/2019-04-07-why-map-no-order/</guid>
      <description>有的小伙伴没留意过 Go map 输出顺序，以为它是稳定的有序的；有的小伙伴知道是无序的，但却不知道为什么？有的却理解错误？今天我们将通过本文，揭开 for range map 的 “神秘” 面纱，看看它内部实现到底是怎么样的，输出顺序到底是怎么样？ 前言 1 2 3 4 5 6 7 8 9 10 11 12 func main() { m := make(map[int32]string) m[0] = &amp;#34;zshipu1&amp;#34; m[1] = &amp;#34;zshipu2&amp;#34; m[2] = &amp;#34;zshipu3&amp;#34; m[3] = &amp;#34;zshipu4&amp;#34; m[4] = &amp;#34;zshipu5&amp;#34;</description>
    </item>
    <item>
      <title>简单围观一下有趣的 //go: 指令</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-03-31-go-ins/</link>
      <pubDate>Sun, 31 Mar 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-03-31-go-ins/</guid>
      <description>前言 如果你平时有翻看源码的习惯，你肯定会发现。咦，怎么有的方法上面总是写着 //go: 这类指令呢。他们到底是干嘛用的？ 今天我们一同揭开他们的面纱，我将简单给你介绍一下，它们都负责些什么 go:linkname //go:linkname localname importpath.name 该指令指示编译器使用 importpath.name 作为源代码中声明为 localname 的变量或函数的目标文件符号名称。但是由于这个伪指令，可以</description>
    </item>
    <item>
      <title>深入理解 Go map：赋值和扩容迁移</title>
      <link>https://index.zshipu.com/go/posts/go/map/2019-03-24-map-assign/</link>
      <pubDate>Sun, 24 Mar 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/map/2019-03-24-map-assign/</guid>
      <description>概要 在 上一章节 中，数据结构小节里讲解了大量基础字段，可能你会疑惑需要 #&amp;amp;（！……#（！￥！ 来干嘛？接下来我们一起简单了解一下基础概念。再开始研讨今天文章的重点内容。我相信这样你能更好的读懂这篇文章 哈希函数 哈希函数，又称散列算法、散列函数。主要作用是通过特定算法将数据根据一</description>
    </item>
    <item>
      <title>深入理解 Go map：初始化和访问元素</title>
      <link>https://index.zshipu.com/go/posts/go/map/2019-03-05-map-access/</link>
      <pubDate>Tue, 05 Mar 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/map/2019-03-05-map-access/</guid>
      <description>从本文开始咱们一起探索 Go map 里面的奥妙吧，看看它的内在是怎么构成的，又分别有什么值得留意的地方？ 第一篇将探讨初始化和访问元素相关板块，咱们带着疑问去学习，例如： 初始化的时候会马上分配内存吗？ 底层数据是如何存储的？ 底层是如何使用 key 去寻找数据的？ 底层是用什么方式解决哈希冲突的？ 数据类型</description>
    </item>
    <item>
      <title>for-loop 与 json.Unmarshal 性能分析概要</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-02-17-for-loop-json-unmarshal/</link>
      <pubDate>Sun, 17 Feb 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-02-17-for-loop-json-unmarshal/</guid>
      <description>在项目中，常常会遇到循环交换赋值的数据处理场景，尤其是 RPC，数据交互格式要转为 Protobuf，赋值是无法避免的。一般会有如下几种做法： for for range json.Marshal/Unmarshal 这时候又面临 “选择困难症”，用哪个好？又想代码量少，又担心性能有没有影响啊&amp;hellip; 为了弄清楚这个疑惑，接下来将分别编写三种使用</description>
    </item>
    <item>
      <title>来，控制一下 goroutine 的并发数量</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2019-01-20-control-goroutine/</link>
      <pubDate>Sun, 20 Jan 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2019-01-20-control-goroutine/</guid>
      <description>问题 1 2 3 4 5 6 7 8 9 10 func main() { userCount := math.MaxInt64 for i := 0; i &amp;lt; userCount; i++ { go func(i int) { // 做一些各种各样的业务逻辑处理 fmt.Printf(&amp;#34;go func: %d\n&amp;#34;, i) time.Sleep(time.Second) }(i) } } 在这里，假设 userCount 是一个外部传入的参数（不可预测，有可能值非常大），有人会全部丢进去循环。想着全部都并发 goroutine 去同时做某一件事。觉得这样子会效率会更高，对不对！ 那么，你觉得这里有没</description>
    </item>
    <item>
      <title>Go Slice 最大容量大小是怎么来的</title>
      <link>https://index.zshipu.com/go/posts/go/slice/2019-01-06-why-slice-max/</link>
      <pubDate>Sun, 06 Jan 2019 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/slice/2019-01-06-why-slice-max/</guid>
      <description>前言 在《深入理解 Go Slice》中，我们提到了 “根据其类型大小去获取能够申请的最大容量大小” 的处理逻辑。今天我们将更深入地去探究一下，底层到底做了什么东西，涉及什么知识点？ Go Slice 对应代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 func makeslice(et *_type, len, cap int) slice { maxElements := maxSliceCap(et.size) if len &amp;lt; 0 || uintptr(len) &amp;gt; maxElements { ... } if cap &amp;lt; len || uintptr(cap) &amp;gt; maxElements { ... }</description>
    </item>
    <item>
      <title>在 Go 中恰到好处的内存对齐</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2018-12-26-go-memory-align/</link>
      <pubDate>Wed, 26 Dec 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2018-12-26-go-memory-align/</guid>
      <description>问题 1 2 3 4 5 6 7 type Part1 struct { a bool b int32 c int8 d int64 e byte } 在开始之前，希望你计算一下 Part1 共占用的大小是多少呢？ 1 2 3 4 5 6 7 8 func main() { fmt.Printf(&amp;#34;bool size: %d\n&amp;#34;, unsafe.Sizeof(bool(true))) fmt.Printf(&amp;#34;int32 size: %d\n&amp;#34;, unsafe.Sizeof(int32(0))) fmt.Printf(&amp;#34;int8 size: %d\n&amp;#34;, unsafe.Sizeof(int8(0))) fmt.Printf(&amp;#34;int64 size: %d\n&amp;#34;, unsafe.Sizeof(int64(0))) fmt.Printf(&amp;#34;byte size: %d\n&amp;#34;, unsafe.Sizeof(byte(0))) fmt.Printf(&amp;#34;string size: %d\n&amp;#34;, unsafe.Sizeof(&amp;#34;zshipu&amp;#34;)) } 输出结果： bool size: 1 int32 size: 4 int8 size: 1 int64 size: 8 byte size: 1 string size: 16 这么一算，Part1 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相</description>
    </item>
    <item>
      <title>有点不安全却又一亮的 Go unsafe.Pointer</title>
      <link>https://index.zshipu.com/go/posts/go/pkg/2018-12-15-unsafe/</link>
      <pubDate>Sat, 15 Dec 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/pkg/2018-12-15-unsafe/</guid>
      <description>在上一篇文章《深入理解 Go Slice》中，大家会发现其底层数据结构使用了 unsafe.Pointer。因此想着再介绍一下其关联知识 前言 在大家学习 Go 的时候，肯定都学过 “Go 的指针是不支持指针运算和转换” 这个知识点。为什么呢？ 首先，Go 是一门静态语言，所有的变量都必须为标量类型。不同的</description>
    </item>
    <item>
      <title>深入理解 Go Slice</title>
      <link>https://index.zshipu.com/go/posts/go/slice/2018-12-11-slice/</link>
      <pubDate>Tue, 11 Dec 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/slice/2018-12-11-slice/</guid>
      <description>是什么 在 Go 中，Slice（切片）是抽象在 Array（数组）之上的特殊类型。为了更好地了解 Slice，第一步需要先对 Array 进行理解。深刻了解 Slice 与 Array 之间的区别后，就能更好的对其底层一番摸索 😄 用法 Array 1 2 3 4 5 6 7 8 9 10 func main() { nums := [3]int{} nums[0] = 1 n := nums[0] n = 2 fmt.Printf(&amp;#34;nums: %v\n&amp;#34;, nums) fmt.Printf(&amp;#34;n: %d\n&amp;#34;, n) } 我们可得知在 Go 中，数组类型需</description>
    </item>
    <item>
      <title>fmt 标准库 --- Print* 是怎么样输出的？</title>
      <link>https://index.zshipu.com/go/posts/go/pkg/2018-12-04-fmt/</link>
      <pubDate>Tue, 04 Dec 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/pkg/2018-12-04-fmt/</guid>
      <description>前言 package main import ( &amp;#34;fmt&amp;#34; ) func main() { fmt.Println(&amp;#34;Hello World!&amp;#34;) } 标准开场见多了，那内部标准库又是怎么输出这段英文的呢？今天一起来围观下源码吧 🤭 原型 func Print(a ...interface{}) (n int, err error) { return Fprint(os.Stdout, a...) } func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } func Printf(format string, a ...interface{}) (n int, err error) { return Fprintf(os.Stdout, format, a...) } Print：使用默认格式说明符打印格式并写入标准输出。当两者都不是字符串时，在操作数之间添加</description>
    </item>
    <item>
      <title>使用 Gomock 进行单元测试</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2018-11-25-gomock/</link>
      <pubDate>Sun, 25 Nov 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2018-11-25-gomock/</guid>
      <description>在实际项目中，需要进行单元测试的时候。却往往发现有一大堆依赖项。这时候就是 Gomock 大显身手的时候了 Gomock 是 Go 语言的一个 mock 框架，官方的那种 🤪 安装 $ go get -u github.com/golang/mock/gomock $ go install github.com/golang/mock/mockgen 第一步：我们将安装 gomock 第三方库和 mock 代码的生成工具 mockgen。而后者可以大大的节省我们的工作量。只需要了解其使用方式就可以 第二步：</description>
    </item>
    <item>
      <title>「连载十」分布式链路追踪 gRPC &#43; Opentracing &#43; Zipkin</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-10-20-zipkin/</link>
      <pubDate>Sat, 20 Oct 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-10-20-zipkin/</guid>
      <description>在实际应用中，你做了那么多 Server 端，写了 N 个 RPC 方法。想看看方法的指标，却无处下手？ 本文将通过 gRPC + Opentracing + Zipkin 搭建一个分布式链路追踪系统来实现查看整个系统的链路、性能等指标。 Opentracing 是什么 OpenTracing 通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现 不过 OpenTracing 并不是标准。因为</description>
    </item>
    <item>
      <title>「连载九」gRPC Deadlines</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-10-16-deadlines/</link>
      <pubDate>Tue, 16 Oct 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-10-16-deadlines/</guid>
      <description>前言 在前面的章节中，已经介绍了 gRPC 的基本用法。那你想想，让它这么裸跑真的没问题吗？ 那么，肯定是有问题了。今天将介绍 gRPC Deadlines 的用法，这一个必备技巧。内容也比较简单 Deadlines Deadlines 意指截止时间，在 gRPC 中强调 TL;DR（Too long, Don&amp;rsquo;t read）并建议始终设定截止日期，为什么呢？ 为什么要设置 当未设置 Deadlines 时，将采用</description>
    </item>
    <item>
      <title>「连载八」对 RPC 方法做自定义认证</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-10-14-per-rpc-credentials/</link>
      <pubDate>Sun, 14 Oct 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-10-14-per-rpc-credentials/</guid>
      <description>前言 在前面的章节中，我们介绍了两种（证书算一种）可全局认证的方法： TLS 证书认证 基于 CA 的 TLS 证书认证 Unary and Stream interceptor 而在实际需求中，常常会对某些模块的 RPC 方法做特殊认证或校验。今天将会讲解、实现这块的功能点 课前知识 type PerRPCCredentials interface { GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) RequireTransportSecurity() bool } 在 gRPC 中默认定义了 PerRPCCredentials，它就</description>
    </item>
    <item>
      <title>「连载七」让你的服务同时提供 HTTP 接口</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-10-12-grpc-http/</link>
      <pubDate>Fri, 12 Oct 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-10-12-grpc-http/</guid>
      <description>前言 接口需要提供给其他业务组访问，但是 RPC 协议不同无法内调，对方问能否走 HTTP 接口，怎么办？ 微信（公众号、小程序）等第三方回调接口只支持 HTTP 接口，怎么办 我相信你在实际工作中都会遇到如上问题，在 gRPC 中都是有解决方案的，本章节将会进行介绍 🤔 为什么可以同时提供 HTTP 接口 关键一点，gRPC 的协议是基于</description>
    </item>
    <item>
      <title>「连载六」Unary and Stream interceptor</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-10-10-interceptor/</link>
      <pubDate>Wed, 10 Oct 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-10-10-interceptor/</guid>
      <description>前言 我想在每个 RPC 方法的前或后做某些事情，怎么做？ 本章节将要介绍的拦截器（interceptor），就能帮你在合适的地方实现这些功能。 有几种方法 在 gRPC 中，大类可分为两种 RPC 方法，与拦截器的对应关系是： 普通方法：一元拦截器（grpc.UnaryInterceptor） 流方法：流拦截器（g</description>
    </item>
    <item>
      <title>「连载五」基于 CA 的 TLS 证书认证</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-10-08-ca-tls/</link>
      <pubDate>Mon, 08 Oct 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-10-08-ca-tls/</guid>
      <description>前言 在上一章节中，我们提出了一个问题。就是如何保证证书的可靠性和有效性？你如何确定你 Server、Client 的证书是对的呢？ CA 为了保证证书的可靠性和有效性，在这里可引入 CA 颁发的根证书的概念。其遵守 X.509 标准 根证书 根证书（root certificate）是属于根证书颁发机构（CA）的</description>
    </item>
    <item>
      <title>「连载四」TLS 证书认证</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-10-07-grpc-tls/</link>
      <pubDate>Sun, 07 Oct 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-10-07-grpc-tls/</guid>
      <description>前言 在前面的章节里，我们介绍了 gRPC 的四种 API 使用方式。是不是很简单呢 😀 此时存在一个安全问题，先前的例子中 gRPC Client/Server 都是明文传输的，会不会有被窃听的风险呢？ 从结论上来讲，是有的。在明文通讯的情况下，你的请求就是裸奔的，有可能被第三方恶意篡改或者伪造为“非法”的数据 抓个包 嗯，明文传输无误。这是</description>
    </item>
    <item>
      <title>log 标准库</title>
      <link>https://index.zshipu.com/go/posts/go/pkg/2018-09-28-log/</link>
      <pubDate>Fri, 28 Sep 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/pkg/2018-09-28-log/</guid>
      <description>日志 输出 2018/09/28 20:03:08 zshipu Blog... 构成 [日期]&amp;lt;空格&amp;gt;[时分秒]&amp;lt;空格&amp;gt;[内容]&amp;lt;\n&amp;gt; 源码剖析 Logger type Logger struct { mu sync.Mutex prefix string flag int out io.Writer buf []byte } mu：互斥锁，用于确保原子的写入 prefix：每行需写入的日志前缀内容 flag：设置日志辅助信息（时间、文件名、行号）的写入。可选如下</description>
    </item>
    <item>
      <title>「连载三」gRPC Streaming, Client and Server</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-09-24-stream-client-server/</link>
      <pubDate>Mon, 24 Sep 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-09-24-stream-client-server/</guid>
      <description>前言 本章节将介绍 gRPC 的流式，分为三种类型： Server-side streaming RPC：服务器端流式 RPC Client-side streaming RPC：客户端流式 RPC Bidirectional streaming RPC：双向流式 RPC 流 任何技术，因为有痛点，所以才有了存在的必要性。如果您想要了解 gRPC 的流式调用，请继续 图 gRPC Streaming 是基于 HTTP/2 的，后续章节再进行详细讲解 为什么不用 Simple RPC 流式为什么要存在呢，是 Simple RPC 有什么</description>
    </item>
    <item>
      <title>「连载二」gRPC Client and Server</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-09-23-client-and-server/</link>
      <pubDate>Sun, 23 Sep 2018 12:30:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-09-23-client-and-server/</guid>
      <description>前言 本章节将使用 Go 来编写 gRPC Server 和 Client，让其互相通讯。在此之上会使用到如下库： google.golang.org/grpc github.com/golang/protobuf/protoc-gen-go 安装 gRPC go get -u google.golang.org/grpc Protocol Buffers v3 wget https://github.com/google/protobuf/releases/download/v3.5.1/protobuf-all-3.5.1.zip unzip protobuf-all-3.5.1.zip cd protobuf-3.5.1/ ./configure make make install 检查是否安装成功 protoc --version 若出现以下错误，执行 ldconfig 命名就能解决这问题 protoc: error while loading shared libraries: libprotobuf.so.15: cannot open shared object file: No such file or directory Protoc Plugin go get -u github.com/golang/protobuf/protoc-gen-go 安装环境若有问题，可参考我先前的文章 《介绍与环境</description>
    </item>
    <item>
      <title>「连载一」gRPC及相关介绍</title>
      <link>https://index.zshipu.com/go/posts/go/grpc/2018-09-22-install/</link>
      <pubDate>Sat, 22 Sep 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc/2018-09-22-install/</guid>
      <description>项目地址：https://github.com/zshipu/go-grpc-example 作为开篇章，将会介绍 gRPC 相关的一些知识。简单来讲 gRPC 是一个 基于 HTTP/2 协议设计的 RPC 框架，它采用了 Protobuf 作为 IDL 你是否有过疑惑，它们都是些什么？本文将会介绍一些常用的知识和概念，更详细的会给出手册地址去深入</description>
    </item>
    <item>
      <title>Go 大杀器之性能剖析 PProf</title>
      <link>https://index.zshipu.com/go/posts/go/tools/2018-09-15-go-tool-pprof/</link>
      <pubDate>Sat, 15 Sep 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/tools/2018-09-15-go-tool-pprof/</guid>
      <description>前言 写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了 结果，性能不佳，什么鬼？😭 想做性能分析 PProf 想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下： runtime/pprof：采集程序（非 Server）的运行数据</description>
    </item>
    <item>
      <title>「连载十七」用Nginx部署Go应用</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-09-01-nginx/</link>
      <pubDate>Sat, 01 Sep 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-09-01-nginx/</guid>
      <description>知识点 Nginx。 反向代理。 本文目标 简单部署后端服务。 做什么 在本章节，我们将简单介绍 Nginx 以及使用 Nginx 来完成对 go-gin-example 的部署，会实现反向代理和简单负载均衡的功能。 Nginx 是什么 Nginx 是一个 Web Server，可以用作反向代理、负载均衡、邮件代理、TCP / UDP、HTTP 服务器等等，它拥有很多吸引人的特性，</description>
    </item>
    <item>
      <title>「番外」请入门 Makefile</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-08-26-makefile/</link>
      <pubDate>Sun, 26 Aug 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-08-26-makefile/</guid>
      <description>知识点 写一个 Makefile 本文目标 含一定复杂度的软件工程，基本上都是先编译 A，再依赖 B，再编译 C&amp;hellip;，最后才执行构建。如果每次都人为编排，又或是每新来一个同事就问你项目 D 怎么构建、重新构建需要注意什么&amp;hellip;等等情况，岂不是要崩溃？ 我们常常会在开源项目中发现 Makefil</description>
    </item>
    <item>
      <title>「连载十六」在图片上绘制文字</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-07-07-font/</link>
      <pubDate>Sat, 07 Jul 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-07-07-font/</guid>
      <description>知识点 字体库使用 图片合成 本文目标 主要实现合并后的海报上绘制文字的功能（这个需求也是常见的很了），内容比较简单。 实现 这里使用的是 微软雅黑 的字体，请点击进行下载并存放到 runtime/fonts 目录下（字体文件占 16 MB 大小） 安装 $ go get -u github.com/golang/freetype 绘制文字 打开 service/article_service/article_poster.go 文件，增加绘制文字的业务逻辑，如下： 1 2 3 4 5 6 7 8 9 10 11</description>
    </item>
    <item>
      <title>「连载十五」生成二维码、合并海报</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-07-05-image/</link>
      <pubDate>Thu, 05 Jul 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-07-05-image/</guid>
      <description>知识点 图片生成 二维码生成 本文目标 在文章的详情页中，我们常常会需要去宣传它，而目前最常见的就是发海报了，今天我们将实现如下功能： 生成二维码 合并海报（背景图 + 二维码） 实现 首先，你需要在 App 配置项中增加二维码及其海报的存储路径，我们约定配置项名称为 QrCodeSavePath，值为 qrc</description>
    </item>
    <item>
      <title>「连载十四」实现导出、导入 Excel</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-06-14-excel/</link>
      <pubDate>Thu, 14 Jun 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-06-14-excel/</guid>
      <description>知识点 导出功能的实现 本文目标 在本节，我们将实现对标签信息的导出、导入功能，这是很标配功能了，希望你掌握基础的使用方式。 另外在本文我们使用了 2 个 Excel 的包，excelize 最初的 XML 格式文件的一些结构，是通过 tealeg/xlsx 格式文件结构演化而来的，因此特意在此都展示了，你可以根据自己的场景和喜爱去使用</description>
    </item>
    <item>
      <title>用 Go 来了解一下 Redis 通讯协议</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2018-06-07-go-redis-protocol/</link>
      <pubDate>Thu, 07 Jun 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2018-06-07-go-redis-protocol/</guid>
      <description>Go、PHP、Java&amp;hellip; 都有那么多包来支撑你使用 Redis，那你是否有想过 有了服务端，有了客户端，他们俩是怎样通讯，又是基于什么通讯协议做出交互的呢？ 介绍 基于我们的目的，本文主要讲解和实践 Redis 的通讯协议 Redis 的客户端和服务端是通过 TCP 连接来进行数据交互， 服务器默认的端口号为</description>
    </item>
    <item>
      <title>「连载十三」优化你的应用结构和实现Redis缓存</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-06-02-application-redis/</link>
      <pubDate>Sat, 02 Jun 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-06-02-application-redis/</guid>
      <description>前言 之前就在想，不少教程或示例的代码设计都是一步到位的（也没问题） 但实际操作的读者真的能够理解透彻为什么吗？左思右想，有了今天这一章的内容，我认为实际经历过一遍印象会更加深刻 本文目标 在本章节，将介绍以下功能的整理： 抽离、分层业务逻辑：减轻 routers.go 内的 api 方法的逻辑（但本文暂不分层 repo</description>
    </item>
    <item>
      <title>「连载十二」优化配置结构及实现图片上传</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-05-27-config-upload/</link>
      <pubDate>Sun, 27 May 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-05-27-config-upload/</guid>
      <description>知识点 重构、调整结构 本文目标 这个应用程序跑了那么久了，越来越大，越来越壮，仿佛我们的产品一样，现在它需要进行小范围重构了，以便于后续的使用，这非常重要。 前言 一天，产品经理突然跟你说文章列表，没有封面图，不够美观，！）&amp;amp;￥！&amp;amp;）#&amp;amp;￥！加一个吧，几分钟的事 你</description>
    </item>
    <item>
      <title>Go 的 fake-useragent 了解一下</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2018-05-21-go-fake-useragent/</link>
      <pubDate>Mon, 21 May 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2018-05-21-go-fake-useragent/</guid>
      <description>有的网站会根据 User-Agent 的不同，跳转到不同（PC、M）的站点，也有根据版本的不同给出不一样的提示等等，而 User-Agent 的变化更是爬虫里的基础姿势 使用 Go 编写网络爬虫或需要模拟浏览器头（User-Agent）的时候，你是否会觉得很麻烦，获取请求头（Request Headers）的 User-Agent 还得找来找去，挺繁琐。</description>
    </item>
    <item>
      <title>「连载十一」Cron定时任务</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-04-29-cron/</link>
      <pubDate>Sun, 29 Apr 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-04-29-cron/</guid>
      <description>知识点 完成定时任务的功能 本文目标 在实际的应用项目中，定时任务的使用是很常见的。你是否有过 Golang 如何做定时任务的疑问，莫非是轮询，在本文中我们将结合我们的项目讲述 Cron。 介绍 我们将使用 cron 这个包，它实现了 cron 规范解析器和任务运行器，简单来讲就是包含了定时任务所需的功能 Cron 表达式格式 字段名 是</description>
    </item>
    <item>
      <title>了解一下Golang的市场行情</title>
      <link>https://index.zshipu.com/go/posts/go/crawler/2018-04-28-go2018/</link>
      <pubDate>Sat, 28 Apr 2018 12:30:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/crawler/2018-04-28-go2018/</guid>
      <description>项目地址：https://github.com/go-crawler/lagou_jobs 如果对你有所帮助，欢迎 Star，给文章来波赞，这样可以让更多的人看见 :) 目标 在工作中 Golang 已是一份子，想让大家了解一下 Golang 的市场行情，也想让更多的人熟悉它。因此主要是展示数据分析的结果 目标站点是 某招</description>
    </item>
    <item>
      <title>「连载十」定制 GORM Callbacks</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-04-15-gorm-callback/</link>
      <pubDate>Sun, 15 Apr 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-04-15-gorm-callback/</guid>
      <description>涉及知识点 GORM 本文目标 GORM itself is powered by Callbacks, so you could fully customize GORM as you want GORM 本身是由回调驱动的，所以我们可以根据需要完全定制 GORM，以此达到我们的目的，如下： 注册一个新的回调 删除现有的回调 替换现有的回调 注册回调的顺序 在 GORM 中包含以上四类 Callbacks，我们结合项目选用 “替换现有的回调” 来解决一个小痛</description>
    </item>
    <item>
      <title>爬取汽车之家 二手车产品库</title>
      <link>https://index.zshipu.com/go/posts/go/crawler/2018-04-01-cars/</link>
      <pubDate>Sun, 01 Apr 2018 12:30:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/crawler/2018-04-01-cars/</guid>
      <description>项目地址：https://github.com/go-crawler/car-prices 目标 最近经常有人在耳边提起汽车之家，也好奇二手车在国内的价格是怎么样的，因此本次的目标站点是 汽车之家 的二手车产品库 分析目标源： 一页共 24 条 含分页，但这个老产品库，在 100 页后会存在问题，因此我们爬</description>
    </item>
    <item>
      <title>「番外」Golang 交叉编译</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-03-26-cgo/</link>
      <pubDate>Mon, 26 Mar 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-03-26-cgo/</guid>
      <description>知识点 跨平台编译 本文目标 在 连载九 讲解构建 Scratch 镜像时，我们编译可执行文件用了另外一个形式的命令，如下： $ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o go-gin-example . 我想你可能会有疑问，今天本文会针对这块进行讲解。 说明 我们将讲解命令各个参数的作用，希望你在阅读时，将每一项串联起来，你会发现这就是交叉编译相关的小知识 也就是 Golang 令</description>
    </item>
    <item>
      <title>「连载九」将Golang应用部署到Docker</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-03-24-golang-docker/</link>
      <pubDate>Sat, 24 Mar 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-03-24-golang-docker/</guid>
      <description>涉及知识点 Go + Docker 本文目标 将我们的 go-gin-example 应用部署到一个 Docker 里，你需要先准备好如下东西： 你需要安装好 docker。 如果上外网比较吃力，需要配好镜像源。 Docker 在这里简单介绍下 Docker，建议深入学习 Docker 是一个开源的轻量级容器技术，让开发者可以打包他们的应用以及应用运行的上下文环境到一个可移植的镜</description>
    </item>
    <item>
      <title>爬取豆瓣电影 Top250</title>
      <link>https://index.zshipu.com/go/posts/go/crawler/2018-03-21-douban-top250/</link>
      <pubDate>Wed, 21 Mar 2018 12:30:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/crawler/2018-03-21-douban-top250/</guid>
      <description>爬虫是标配了，看数据那一刻很有趣。第一个就从最最最简单最基础的爬虫开始写起吧！ 项目地址：https://github.com/go-crawler/douban-movie 目标 我们的目标站点是 豆瓣电影 Top250，估计大家都很眼熟了 本次爬取 8 个字段，用于简单的概括分析。具体的字段</description>
    </item>
    <item>
      <title>「连载八」为它加上Swagger</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-03-18-swagger/</link>
      <pubDate>Sun, 18 Mar 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-03-18-swagger/</guid>
      <description>涉及知识点 Swagger 本文目标 一个好的 API&#39;s，必然离不开一个好的API文档，如果要开发纯手写 API 文档，不存在的（很难持续维护），因此我们要自动生成接口文档。 安装 swag $ go get -u github.com/swaggo/swag/cmd/swag@v1.6.5 若 $GOROOT/bin 没有加入$PATH中，你需要执行将其可执行文件移动到$GOBIN下 mv $GOPATH/bin/swag /usr/local/go/bin 验证是否安装成功 检查 $GOBIN 下是否有 swag 文件，如</description>
    </item>
    <item>
      <title>「连载七」优雅的重启服务</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-03-15-reload-http/</link>
      <pubDate>Thu, 15 Mar 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-03-15-reload-http/</guid>
      <description>知识点 信号量的了解。 应用热更新。 本文目标 在前面编写案例代码时，我相信你会想到，每次更新完代码，更新完配置文件后，就直接这么 ctrl+c 真的没问题吗，ctrl+c到底做了些什么事情呢？ 在这一节中我们简单讲述 ctrl+c 背后的信号以及如何在Gin中优雅的重启服务，也就是对 HTTP 服务进行热更新。 ctrl + c 内核在某</description>
    </item>
    <item>
      <title>聊一聊，Go 的相对路径问题</title>
      <link>https://index.zshipu.com/go/posts/go/talk/2018-03-13-golang-relatively-path/</link>
      <pubDate>Tue, 13 Mar 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/talk/2018-03-13-golang-relatively-path/</guid>
      <description>前言 Golang 中存在各种运行方式，如何正确的引用文件路径成为一个值得商议的问题 以 gin-blog 为例，当我们在项目根目录下，执行 go run main.go 时能够正常运行（go build也是正常的） [$ gin-blog]# go run main.go [GIN-debug] [WARNING] Running in &amp;#34;debug&amp;#34; mode. Switch to &amp;#34;release&amp;#34; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /api/v1/tags --&amp;gt; gin-blog/routers/api/v1.GetTags (3 handlers) ... 那么在不同的目录层级下，不同的方式运行，又是怎么样的呢，带</description>
    </item>
    <item>
      <title>「连载三」Swagger了解一下</title>
      <link>https://index.zshipu.com/go/posts/go/grpc-gateway/2018-03-04-swagger/</link>
      <pubDate>Sun, 04 Mar 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc-gateway/2018-03-04-swagger/</guid>
      <description>在上一节，我们完成了一个服务端同时支持Rpc和RESTful Api后，你以为自己大功告成了，结果突然发现要写Api文档和前端同事对接= = 。。。 你寻思有没有什么组件能够自动化生成Api文档来解决这个问题，就在这时你发现了Swagger，一起了解一下吧！ 介绍 Swagger Swagger是全球最大</description>
    </item>
    <item>
      <title>「连载二」Hello World</title>
      <link>https://index.zshipu.com/go/posts/go/grpc-gateway/2018-02-27-hello-world/</link>
      <pubDate>Tue, 27 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc-gateway/2018-02-27-hello-world/</guid>
      <description>这节将开始编写一个复杂的Hello World，涉及到许多的知识，建议大家认真思考其中的概念 需求 由于本实践偏向Grpc+Grpc Gateway的方面，我们的需求是同一个服务端支持Rpc和Restful Api，那么就意味着http2、TLS等等的应用，功能方面就是一个服务端能够接受来</description>
    </item>
    <item>
      <title>「连载一」gRPC介绍与环境安装</title>
      <link>https://index.zshipu.com/go/posts/go/grpc-gateway/2018-02-23-install/</link>
      <pubDate>Fri, 23 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/grpc-gateway/2018-02-23-install/</guid>
      <description>假定我们有一个项目需求，希望用Rpc作为内部API的通讯，同时也想对外提供Restful Api，写两套又太繁琐不符合 于是我们想到了Grpc以及Grpc Gateway，这就是我们所需要的 准备环节 在正式开始我们的Grpc+Grpc Gateway实践前，我们需要先配置好我们的开发环境 Grpc</description>
    </item>
    <item>
      <title>「连载六」编写一个简单的文件日志</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-02-15-log/</link>
      <pubDate>Thu, 15 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-02-15-log/</guid>
      <description>涉及知识点 自定义 log。 本文目标 在上一节中，我们解决了 API&amp;rsquo;s 可以任意访问的问题，那么我们现在还有一个问题，就是我们的日志，都是输出到控制台上的，这显然对于一个项目来说是不合理的，因此我们这一节简单封装log库，使其支持简单的文件日志！ 新建logging包 我们在pkg下新建loggin</description>
    </item>
    <item>
      <title>「连载五」使用 JWT 进行身份校验</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-02-14-jwt/</link>
      <pubDate>Wed, 14 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-02-14-jwt/</guid>
      <description>涉及知识点 JWT 本文目标 在前面几节中，我们已经基本的完成了 API&amp;rsquo;s 的编写，但是，还存在一些非常严重的问题，例如，我们现在的 API 是可以随意调用的，这显然还不安全全，在本文中我们通过 jwt-go （GoDoc）的方式来简单解决这个问题。 下载依赖包 首先，我们下载 jwt-go 的依赖包，如下： go get -u github.com/dgrijalva/jwt-go 编写 jwt 工具包 我们需要编</description>
    </item>
    <item>
      <title>「连载四」Gin搭建Blog API&#39;s （三）</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-02-13-api-03/</link>
      <pubDate>Tue, 13 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-02-13-api-03/</guid>
      <description>涉及知识点 Gin：Golang 的一个微框架，性能极佳。 beego-validation：本节采用的 beego 的表单验证库，中文文档。 gorm，对开发人员友好的 ORM 框架，英文文档 com，一个小而美的工具包。 本文目标 完成博客的文章类接口定义和编写 定义接口 本节编写文章的逻辑，我们定义一下接口吧！</description>
    </item>
    <item>
      <title>「连载三」Gin搭建Blog API&#39;s （二）</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-02-12-api-02/</link>
      <pubDate>Mon, 12 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-02-12-api-02/</guid>
      <description>涉及知识点 Gin：Golang 的一个微框架，性能极佳。 beego-validation：本节采用的 beego 的表单验证库，中文文档。 gorm，对开发人员友好的 ORM 框架，英文文档 com，一个小而美的工具包。 本文目标 完成博客的标签类接口定义和编写 定义接口 本节正是编写标签的逻辑，我们想一想，一般</description>
    </item>
    <item>
      <title>「连载二」Gin搭建Blog API&#39;s （一）</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-02-11-api-01/</link>
      <pubDate>Sun, 11 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-02-11-api-01/</guid>
      <description>思考 首先，在一个初始项目开始前，大家都要思考一下 程序的文本配置写在代码中，好吗？ API 的错误码硬编码在程序中，合适吗？ db 句柄谁都去Open，没有统一管理，好吗？ 获取分页等公共参数，谁都自己写一套逻辑，好吗？ 显然在较正规的项目中，这些问题的答案都是不可以，为了解决这些问题，我们挑选一款</description>
    </item>
    <item>
      <title>「连载一」Go 介绍与环境安装</title>
      <link>https://index.zshipu.com/go/posts/go/gin/2018-02-10-install/</link>
      <pubDate>Sat, 10 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://index.zshipu.com/go/posts/go/gin/2018-02-10-install/</guid>
      <description>本文目标 学会安装 Go。 知道什么是 Go。 知道什么是 Go modules。 了解 Go modules 的小历史。 学会简单的使用 Go modules。 了解 Gin，并简单跑起一个 Demo。 准备环节 安装 Go Centos 首先，根据对应的操作系统选择安装包 下载，在这里我使用的是 Centos 64 位系统，如下： 1 2 3 4 5 $ wget https://studygolang.com/dl/golang/go1.13.1.linux-amd64.tar.gz $ tar -zxvf go1.13.1.linux-amd64.tar.gz $ mv go/ /usr/local/ 配置 /etc/profile</description>
    </item>
  </channel>
</rss>
