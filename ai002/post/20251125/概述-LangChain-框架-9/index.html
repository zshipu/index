<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>概述 - LangChain 框架 (9) --知识铺 | 知识铺的博客</title>
    <meta property="og:title" content="概述 - LangChain 框架 (9) --知识铺 - 知识铺的博客">
    <meta property="og:type" content="article">
    
    <meta property="article:published_time" content='2026-01-08T09:07:08&#43;08:00'>
    
    
    <meta property="article:modified_time" content='2026-01-08T09:07:08&#43;08:00'>
    
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="概述 - LangChain 框架 (9) --知识铺">
    
    <meta name="author" content="知识铺">
    <meta property="og:url" content="https://index.zshipu.com/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-9/">
    <link rel="shortcut icon" href='/ai002/favicon.ico' type="image/x-icon">

    <link rel="stylesheet" href='/ai002/css/normalize.css'>
    <link rel="stylesheet" href='/ai002/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    

    

    
    
    
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-WLWJSST');</script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BY5XJ2PJ93"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-BY5XJ2PJ93');
    </script>
    
</head>

<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://index.zshipu.com/ai002">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://index.zshipu.com/ai002">首页</a>
                    
                    <a  href="https://index.zshipu.com/ai001/" title="AI技术">AI技术</a>
                    
                    <a  href="https://index.zshipu.com" title="总站">总站</a>
                    
                    <a  href="https://index.zshipu.com/ai002/archives/" title="归档">归档</a>
                    
                    <a  href="https://index.zshipu.com/ai002/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#多代理系统httpslanggraphcomcnconceptsmulti_agent1htmlmulti-agent-systems-永久链接">多代理系统<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#multi-agent-systems" title="永久链接">¶</a></a></li>
    <li><a href="#多代理架构httpslanggraphcomcnconceptsmulti_agent1htmlmulti-agent-architectures-永久链接">多代理架构<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#multi-agent-architectures" title="永久链接">¶</a></a>
      <ul>
        <li><a href="#交接httpslanggraphcomcnconceptsmulti_agent1htmlhandoffs-永久链接">交接<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs" title="永久链接">¶</a></a></li>
        <li><a href="#网络httpslanggraphcomcnconceptsmulti_agent1htmlnetwork-永久链接">网络<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#network" title="永久链接">¶</a></a></li>
        <li><a href="#主管httpslanggraphcomcnconceptsmulti_agent1htmlsupervisor-永久链接">主管<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#supervisor" title="永久链接">¶</a></a></li>
        <li><a href="#主管工具调用httpslanggraphcomcnconceptsmulti_agent1htmlsupervisor-tool-calling-永久链接">主管（工具调用）<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#supervisor-tool-calling" title="永久链接">¶</a></a></li>
        <li><a href="#分层httpslanggraphcomcnconceptsmulti_agent1htmlhierarchical-永久链接">分层<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#hierarchical" title="永久链接">¶</a></a></li>
        <li><a href="#自定义多代理工作流httpslanggraphcomcnconceptsmulti_agent1htmlcustom-multi-agent-workflow-永久链接">自定义多代理工作流<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#custom-multi-agent-workflow" title="永久链接">¶</a></a></li>
      </ul>
    </li>
    <li><a href="#通信与状态管理httpslanggraphcomcnconceptsmulti_agent1htmlcommunication-and-state-management-永久链接">通信与状态管理<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#communication-and-state-management" title="永久链接">¶</a></a>
      <ul>
        <li><a href="#交接与工具调用httpslanggraphcomcnconceptsmulti_agent1htmlhandoffs-vs-tool-calls-永久链接">交接与工具调用<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs-vs-tool-calls" title="永久链接">¶</a></a></li>
        <li><a href="#代理间的消息传递httpslanggraphcomcnconceptsmulti_agent1htmlmessage-passing-between-agents-永久链接">代理间的消息传递<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#message-passing-between-agents" title="永久链接">¶</a></a></li>
        <li><a href="#在消息历史中表示交接httpslanggraphcomcnconceptsmulti_agent1htmlrepresenting-handoffs-in-message-history-永久链接">在消息历史中表示交接<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#representing-handoffs-in-message-history" title="永久链接">¶</a></a></li>
        <li><a href="#子代理的状态管理httpslanggraphcomcnconceptsmulti_agent1htmlstate-management-for-subagents-永久链接">子代理的状态管理<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#state-management-for-subagents" title="永久链接">¶</a></a></li>
        <li><a href="#使用不同的状态模式httpslanggraphcomcnconceptsmulti_agent1htmlusing-different-state-schemas-永久链接">使用不同的状态模式<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#using-different-state-schemas" title="永久链接">¶</a></a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">概述 - LangChain 框架 (9) --知识铺</h1>
        </header>
        <date class="post-meta meta-date">
            2026年1月8日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p><a href="https://github.com/langchain-ai/langgraph/edit/main/docs/docs/concepts/multi_agent.md" title="Edit this page"></a></p>
<h2 id="多代理系统httpslanggraphcomcnconceptsmulti_agent1htmlmulti-agent-systems-永久链接">多代理系统<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#multi-agent-systems" title="永久链接">¶</a></h2>
<p>一个<a href="https://langgraph.com.cn/concepts/agentic_concepts.1.html#agent-architectures">代理</a>是一个_使用大型语言模型（LLM）来决定应用程序控制流的系统_。随着这些系统的开发，它们可能会随着时间变得越来越复杂，从而更难管理和扩展。例如，你可能会遇到以下问题：</p>
<ul>
<li>代理拥有的工具过多，在决定下一步调用哪个工具时做出糟糕的决策</li>
<li>上下文变得过于复杂，单个代理难以跟踪</li>
<li>系统需要多个专业领域（例如，规划师、研究员、数学专家等）</li>
</ul>
<p>为了解决这些问题，你可以考虑将应用程序分解成多个更小、独立的代理，并将它们组合成一个<strong>多代理系统</strong>。这些独立的代理可以像一个提示和一次 LLM 调用那样简单，也可以像一个 <a href="https://langgraph.com.cn/concepts/agentic_concepts.1.html#tool-calling-agent">ReAct</a> 代理那样复杂（甚至更复杂！）。</p>
<p>使用多代理系统的主要优点是：</p>
<ul>
<li><strong>模块化</strong>：分离的代理使开发、测试和维护代理系统变得更容易。</li>
<li><strong>专业化</strong>：你可以创建专注于特定领域的专家代理，这有助于提高整个系统的性能。</li>
<li><strong>控制</strong>：你可以明确控制代理如何通信（而不是依赖函数调用）。</li>
</ul>
<h2 id="多代理架构httpslanggraphcomcnconceptsmulti_agent1htmlmulti-agent-architectures-永久链接">多代理架构<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#multi-agent-architectures" title="永久链接">¶</a></h2>
<p>
        <img class="mx-auto" alt="" src="https://api.995120.cn/ecgdata/other/2026-01-08/6154620260108160857Evb1rpkZ.png" />   
    </p>
<p>在多代理系统中，有几种连接代理的方法：</p>
<ul>
<li><strong>网络</strong>：每个代理都可以与<a href="https://langgraph.com.cn/tutorials/multi_agent/multi-agent-collaboration/index.html">所有其他代理</a>通信。任何代理都可以决定下一步调用哪个其他代理。</li>
<li><strong>主管</strong>：每个代理都与一个<a href="https://langgraph.com.cn/tutorials/multi_agent/agent_supervisor.1.html">主管</a>代理通信。主管代理决定下一步应该调用哪个代理。</li>
<li><strong>主管（工具调用）</strong>：这是主管架构的一个特例。单个代理可以表示为工具。在这种情况下，主管代理使用一个支持工具调用的 LLM 来决定调用哪个代理工具，以及传递给这些代理的参数。</li>
<li><strong>分层</strong>：你可以定义一个具有<a href="https://langgraph.com.cn/tutorials/multi_agent/hierarchical_agent_teams/index.html">主管之主管</a>的多代理系统。这是主管架构的泛化，允许更复杂的控制流。</li>
<li><strong>自定义多代理工作流</strong>：每个代理只与部分代理通信。流程的部分是确定性的，并且只有某些代理可以决定下一步调用哪个其他代理。</li>
</ul>
<h3 id="交接httpslanggraphcomcnconceptsmulti_agent1htmlhandoffs-永久链接">交接<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs" title="永久链接">¶</a></h3>
<p>在多代理架构中，代理可以表示为图节点。每个代理节点执行其步骤，并决定是结束执行还是路由到另一个代理，包括可能路由到自身（例如，循环运行）。多代理交互中的一个常见模式是<strong>交接</strong>，即一个代理将控制权_移交给_另一个代理。交接允许你指定：</p>
<ul>
<li><strong>目标</strong>：要导航到的目标代理（例如，要去的节点的名称）</li>
<li><strong>有效载荷</strong>：<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#communication-and-state-management">要传递给该代理的信息</a>（例如，状态更新）</li>
</ul>
<p>为了在 LangGraph 中实现交接，代理节点可以返回<a href="https://langgraph.com.cn/concepts/low_level.1.html#command"><code>Command</code></a>对象，该对象允许你结合控制流和状态更新。</p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-0-1&#34;&gt;def agent(state) -&amp;gt; Command[Literal[&#34;agent&#34;, &#34;another_agent&#34;]]:
&lt;span id=&#34;__span-0-2&#34;&gt;    # the condition for routing/halting can be anything, e.g. LLM tool call / structured output, etc.
&lt;span id=&#34;__span-0-3&#34;&gt;    goto = get_next_agent(...)  # &#39;agent&#39; / &#39;another_agent&#39;
&lt;span id=&#34;__span-0-4&#34;&gt;    return Command(
&lt;span id=&#34;__span-0-5&#34;&gt;        # Specify which agent to call next
&lt;span id=&#34;__span-0-6&#34;&gt;        goto=goto,
&lt;span id=&#34;__span-0-7&#34;&gt;        # Update the graph state
&lt;span id=&#34;__span-0-8&#34;&gt;        update={&#34;my_state_key&#34;: &#34;my_state_value&#34;}
&lt;span id=&#34;__span-0-9&#34;&gt;    )
</code></pre><p>在更复杂的场景中，如果每个代理节点本身都是一个图（即<a href="https://langgraph.com.cn/concepts/subgraphs.1.html">子图</a>），那么其中一个代理子图中的节点可能希望导航到不同的代理。例如，如果你有两个代理 <code>alice</code> 和 <code>bob</code>（父图中的子图节点），并且 <code>alice</code> 需要导航到 <code>bob</code>，你可以在 <code>Command</code> 对象中设置 <code>graph=Command.PARENT</code></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-1-1&#34;&gt;def some_node_inside_alice(state):
&lt;span id=&#34;__span-1-2&#34;&gt;    return Command(
&lt;span id=&#34;__span-1-3&#34;&gt;        goto=&#34;bob&#34;,
&lt;span id=&#34;__span-1-4&#34;&gt;        update={&#34;my_state_key&#34;: &#34;my_state_value&#34;},
&lt;span id=&#34;__span-1-5&#34;&gt;        # specify which graph to navigate to (defaults to the current graph)
&lt;span id=&#34;__span-1-6&#34;&gt;        graph=Command.PARENT,
&lt;span id=&#34;__span-1-7&#34;&gt;    )
</code></pre><p>注意</p>
<p>如果你需要支持使用 <code>Command(graph=Command.PARENT)</code> 进行通信的子图的可视化，你需要将它们包装在一个带有 <code>Command</code> 注解的节点函数中，例如，而不是这样：</p>
<p>你需要这样做：</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-3-1&#34;&gt;def call_alice(state) -&amp;gt; Command[Literal[&#34;bob&#34;]]:
&lt;span id=&#34;__span-3-2&#34;&gt;    return alice.invoke(state)
&lt;span id=&#34;__span-3-3&#34;&gt;
&lt;span id=&#34;__span-3-4&#34;&gt;builder.add_node(&#34;alice&#34;, call_alice)
</code></pre><h4 id="作为工具的交接httpslanggraphcomcnconceptsmulti_agent1htmlhandoffs-as-tools-永久链接">作为工具的交接<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs-as-tools" title="永久链接">¶</a></h4>
<p>最常见的代理类型之一是<a href="https://langgraph.com.cn/agents/overview.1.html">工具调用代理</a>。对于这些类型的代理，一种常见模式是将交接包装在工具调用中，例如：</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->tool<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-4-1&#34;&gt;from langchain_core.tools import tool
&lt;span id=&#34;__span-4-2&#34;&gt;
&lt;span id=&#34;__span-4-3&#34;&gt;def transfer_to_bob():
&lt;span id=&#34;__span-4-4&#34;&gt;    &#34;&#34;&#34;Transfer to bob.&#34;&#34;&#34;
&lt;span id=&#34;__span-4-5&#34;&gt;    return Command(
&lt;span id=&#34;__span-4-6&#34;&gt;        # name of the agent (node) to go to
&lt;span id=&#34;__span-4-7&#34;&gt;        goto=&#34;bob&#34;,
&lt;span id=&#34;__span-4-8&#34;&gt;        # data to send to the agent
&lt;span id=&#34;__span-4-9&#34;&gt;        update={&#34;my_state_key&#34;: &#34;my_state_value&#34;},
&lt;span id=&#34;__span-4-10&#34;&gt;        # indicate to LangGraph that we need to navigate to
&lt;span id=&#34;__span-4-11&#34;&gt;        # agent node in a parent graph
&lt;span id=&#34;__span-4-12&#34;&gt;        graph=Command.PARENT,
&lt;span id=&#34;__span-4-13&#34;&gt;    )
</code></pre><p>这是从工具更新图状态的特例，除了状态更新外，还包括控制流。</p>
<p>重要</p>
<p>如果你想使用返回 <code>Command</code> 的工具，你可以使用预置的 [<code>create_react_agent</code>](<a href="https://langgraph.com.cn/reference/agents.1.html#langgraph.prebuilt.chat_agent_executor.create_react_agent">https://langgraph.com.cn/reference/agents.1.html#langgraph.prebuilt.chat_agent_executor.create_react_agent</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->create_react_agent<!-- raw HTML omitted -->&rdquo;) / [<code>ToolNode</code>](<a href="https://langgraph.com.cn/reference/agents.1.html#langgraph.prebuilt.tool_node.ToolNode">https://langgraph.com.cn/reference/agents.1.html#langgraph.prebuilt.tool_node.ToolNode</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->ToolNode<!-- raw HTML omitted -->&rdquo;) 组件，或者实现你自己的工具执行节点，该节点收集工具返回的 <code>Command</code> 对象并返回它们的列表，例如：</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-5-1&#34;&gt;def call_tools(state):
&lt;span id=&#34;__span-5-2&#34;&gt;    ...
&lt;span id=&#34;__span-5-3&#34;&gt;    commands = [tools_by_name[tool_call[&#34;name&#34;]].invoke(tool_call) for tool_call in tool_calls]
&lt;span id=&#34;__span-5-4&#34;&gt;    return commands
</code></pre><p>现在我们来仔细看看不同的多代理架构。</p>
<h3 id="网络httpslanggraphcomcnconceptsmulti_agent1htmlnetwork-永久链接">网络<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#network" title="永久链接">¶</a></h3>
<p>在这种架构中，代理被定义为图节点。每个代理都可以与所有其他代理通信（多对多连接），并且可以决定下一步调用哪个代理。这种架构适用于没有明确代理层次结构或特定代理调用顺序的问题。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->ChatOpenAI<!-- raw HTML omitted --> | <!-- raw HTML omitted -->Command<!-- raw HTML omitted --> | <!-- raw HTML omitted -->StateGraph<!-- raw HTML omitted --> | <!-- raw HTML omitted -->START<!-- raw HTML omitted --> | <!-- raw HTML omitted -->END<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-6-1&#34;&gt;from typing import Literal
&lt;span id=&#34;__span-6-2&#34;&gt;from langchain_openai import ChatOpenAI
&lt;span id=&#34;__span-6-3&#34;&gt;from langgraph.types import Command
&lt;span id=&#34;__span-6-4&#34;&gt;from langgraph.graph import StateGraph, MessagesState, START, END
&lt;span id=&#34;__span-6-5&#34;&gt;
&lt;span id=&#34;__span-6-6&#34;&gt;model = ChatOpenAI()
&lt;span id=&#34;__span-6-7&#34;&gt;
&lt;span id=&#34;__span-6-8&#34;&gt;def agent_1(state: MessagesState) -&amp;gt; Command[Literal[&#34;agent_2&#34;, &#34;agent_3&#34;, END]]:
&lt;span id=&#34;__span-6-9&#34;&gt;    # you can pass relevant parts of the state to the LLM (e.g., state[&#34;messages&#34;])
&lt;span id=&#34;__span-6-10&#34;&gt;    # to determine which agent to call next. a common pattern is to call the model
&lt;span id=&#34;__span-6-11&#34;&gt;    # with a structured output (e.g. force it to return an output with a &#34;next_agent&#34; field)
&lt;span id=&#34;__span-6-12&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-6-13&#34;&gt;    # route to one of the agents or exit based on the LLM&#39;s decision
&lt;span id=&#34;__span-6-14&#34;&gt;    # if the LLM returns &#34;__end__&#34;, the graph will finish execution
&lt;span id=&#34;__span-6-15&#34;&gt;    return Command(
&lt;span id=&#34;__span-6-16&#34;&gt;        goto=response[&#34;next_agent&#34;],
&lt;span id=&#34;__span-6-17&#34;&gt;        update={&#34;messages&#34;: [response[&#34;content&#34;]]},
&lt;span id=&#34;__span-6-18&#34;&gt;    )
&lt;span id=&#34;__span-6-19&#34;&gt;
&lt;span id=&#34;__span-6-20&#34;&gt;def agent_2(state: MessagesState) -&amp;gt; Command[Literal[&#34;agent_1&#34;, &#34;agent_3&#34;, END]]:
&lt;span id=&#34;__span-6-21&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-6-22&#34;&gt;    return Command(
&lt;span id=&#34;__span-6-23&#34;&gt;        goto=response[&#34;next_agent&#34;],
&lt;span id=&#34;__span-6-24&#34;&gt;        update={&#34;messages&#34;: [response[&#34;content&#34;]]},
&lt;span id=&#34;__span-6-25&#34;&gt;    )
&lt;span id=&#34;__span-6-26&#34;&gt;
&lt;span id=&#34;__span-6-27&#34;&gt;def agent_3(state: MessagesState) -&amp;gt; Command[Literal[&#34;agent_1&#34;, &#34;agent_2&#34;, END]]:
&lt;span id=&#34;__span-6-28&#34;&gt;    ...
&lt;span id=&#34;__span-6-29&#34;&gt;    return Command(
&lt;span id=&#34;__span-6-30&#34;&gt;        goto=response[&#34;next_agent&#34;],
&lt;span id=&#34;__span-6-31&#34;&gt;        update={&#34;messages&#34;: [response[&#34;content&#34;]]},
&lt;span id=&#34;__span-6-32&#34;&gt;    )
&lt;span id=&#34;__span-6-33&#34;&gt;
&lt;span id=&#34;__span-6-34&#34;&gt;builder = StateGraph(MessagesState)
&lt;span id=&#34;__span-6-35&#34;&gt;builder.add_node(agent_1)
&lt;span id=&#34;__span-6-36&#34;&gt;builder.add_node(agent_2)
&lt;span id=&#34;__span-6-37&#34;&gt;builder.add_node(agent_3)
&lt;span id=&#34;__span-6-38&#34;&gt;
&lt;span id=&#34;__span-6-39&#34;&gt;builder.add_edge(START, &#34;agent_1&#34;)
&lt;span id=&#34;__span-6-40&#34;&gt;network = builder.compile()
</code></pre><h3 id="主管httpslanggraphcomcnconceptsmulti_agent1htmlsupervisor-永久链接">主管<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#supervisor" title="永久链接">¶</a></h3>
<p>在这种架构中，我们将代理定义为节点，并添加一个主管节点（LLM），该节点决定接下来应该调用哪个代理节点。我们使用<a href="https://langgraph.com.cn/concepts/low_level.1.html#command"><code>Command</code></a>根据主管的决策将执行路由到适当的代理节点。这种架构也适用于并行运行多个代理或使用<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#map-reduce-and-the-send-api">Map-Reduce</a>模式。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->ChatOpenAI<!-- raw HTML omitted --> | <!-- raw HTML omitted -->Command<!-- raw HTML omitted --> | <!-- raw HTML omitted -->StateGraph<!-- raw HTML omitted --> | <!-- raw HTML omitted -->START<!-- raw HTML omitted --> | <!-- raw HTML omitted -->END<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-7-1&#34;&gt;from typing import Literal
&lt;span id=&#34;__span-7-2&#34;&gt;from langchain_openai import ChatOpenAI
&lt;span id=&#34;__span-7-3&#34;&gt;from langgraph.types import Command
&lt;span id=&#34;__span-7-4&#34;&gt;from langgraph.graph import StateGraph, MessagesState, START, END
&lt;span id=&#34;__span-7-5&#34;&gt;
&lt;span id=&#34;__span-7-6&#34;&gt;model = ChatOpenAI()
&lt;span id=&#34;__span-7-7&#34;&gt;
&lt;span id=&#34;__span-7-8&#34;&gt;def supervisor(state: MessagesState) -&amp;gt; Command[Literal[&#34;agent_1&#34;, &#34;agent_2&#34;, END]]:
&lt;span id=&#34;__span-7-9&#34;&gt;    # you can pass relevant parts of the state to the LLM (e.g., state[&#34;messages&#34;])
&lt;span id=&#34;__span-7-10&#34;&gt;    # to determine which agent to call next. a common pattern is to call the model
&lt;span id=&#34;__span-7-11&#34;&gt;    # with a structured output (e.g. force it to return an output with a &#34;next_agent&#34; field)
&lt;span id=&#34;__span-7-12&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-7-13&#34;&gt;    # route to one of the agents or exit based on the supervisor&#39;s decision
&lt;span id=&#34;__span-7-14&#34;&gt;    # if the supervisor returns &#34;__end__&#34;, the graph will finish execution
&lt;span id=&#34;__span-7-15&#34;&gt;    return Command(goto=response[&#34;next_agent&#34;])
&lt;span id=&#34;__span-7-16&#34;&gt;
&lt;span id=&#34;__span-7-17&#34;&gt;def agent_1(state: MessagesState) -&amp;gt; Command[Literal[&#34;supervisor&#34;]]:
&lt;span id=&#34;__span-7-18&#34;&gt;    # you can pass relevant parts of the state to the LLM (e.g., state[&#34;messages&#34;])
&lt;span id=&#34;__span-7-19&#34;&gt;    # and add any additional logic (different models, custom prompts, structured output, etc.)
&lt;span id=&#34;__span-7-20&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-7-21&#34;&gt;    return Command(
&lt;span id=&#34;__span-7-22&#34;&gt;        goto=&#34;supervisor&#34;,
&lt;span id=&#34;__span-7-23&#34;&gt;        update={&#34;messages&#34;: [response]},
&lt;span id=&#34;__span-7-24&#34;&gt;    )
&lt;span id=&#34;__span-7-25&#34;&gt;
&lt;span id=&#34;__span-7-26&#34;&gt;def agent_2(state: MessagesState) -&amp;gt; Command[Literal[&#34;supervisor&#34;]]:
&lt;span id=&#34;__span-7-27&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-7-28&#34;&gt;    return Command(
&lt;span id=&#34;__span-7-29&#34;&gt;        goto=&#34;supervisor&#34;,
&lt;span id=&#34;__span-7-30&#34;&gt;        update={&#34;messages&#34;: [response]},
&lt;span id=&#34;__span-7-31&#34;&gt;    )
&lt;span id=&#34;__span-7-32&#34;&gt;
&lt;span id=&#34;__span-7-33&#34;&gt;builder = StateGraph(MessagesState)
&lt;span id=&#34;__span-7-34&#34;&gt;builder.add_node(supervisor)
&lt;span id=&#34;__span-7-35&#34;&gt;builder.add_node(agent_1)
&lt;span id=&#34;__span-7-36&#34;&gt;builder.add_node(agent_2)
&lt;span id=&#34;__span-7-37&#34;&gt;
&lt;span id=&#34;__span-7-38&#34;&gt;builder.add_edge(START, &#34;supervisor&#34;)
&lt;span id=&#34;__span-7-39&#34;&gt;
&lt;span id=&#34;__span-7-40&#34;&gt;supervisor = builder.compile()
</code></pre><p>查看此<a href="https://langgraph.com.cn/tutorials/multi_agent/agent_supervisor.1.html">教程</a>，了解主管多代理架构的示例。</p>
<h3 id="主管工具调用httpslanggraphcomcnconceptsmulti_agent1htmlsupervisor-tool-calling-永久链接">主管（工具调用）<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#supervisor-tool-calling" title="永久链接">¶</a></h3>
<p>在<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#supervisor">主管</a>架构的这个变体中，我们定义了一个主管<a href="https://langgraph.com.cn/concepts/agentic_concepts.1.html#agent-architectures">代理</a>，负责调用子代理。子代理作为工具暴露给主管，主管代理决定下一步调用哪个工具。主管代理遵循<a href="https://langgraph.com.cn/concepts/agentic_concepts.1.html#tool-calling-agent">标准实现</a>，即 LLM 在一个 while 循环中运行，不断调用工具直到决定停止。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->ChatOpenAI<!-- raw HTML omitted --> | <!-- raw HTML omitted -->InjectedState<!-- raw HTML omitted --> | <!-- raw HTML omitted -->create_react_agent<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-8-1&#34;&gt;from typing import Annotated
&lt;span id=&#34;__span-8-2&#34;&gt;from langchain_openai import ChatOpenAI
&lt;span id=&#34;__span-8-3&#34;&gt;from langgraph.prebuilt import InjectedState, create_react_agent
&lt;span id=&#34;__span-8-4&#34;&gt;
&lt;span id=&#34;__span-8-5&#34;&gt;model = ChatOpenAI()
&lt;span id=&#34;__span-8-6&#34;&gt;
&lt;span id=&#34;__span-8-7&#34;&gt;# this is the agent function that will be called as tool
&lt;span id=&#34;__span-8-8&#34;&gt;# notice that you can pass the state to the tool via InjectedState annotation
&lt;span id=&#34;__span-8-9&#34;&gt;def agent_1(state: Annotated[dict, InjectedState]):
&lt;span id=&#34;__span-8-10&#34;&gt;    # you can pass relevant parts of the state to the LLM (e.g., state[&#34;messages&#34;])
&lt;span id=&#34;__span-8-11&#34;&gt;    # and add any additional logic (different models, custom prompts, structured output, etc.)
&lt;span id=&#34;__span-8-12&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-8-13&#34;&gt;    # return the LLM response as a string (expected tool response format)
&lt;span id=&#34;__span-8-14&#34;&gt;    # this will be automatically turned to ToolMessage
&lt;span id=&#34;__span-8-15&#34;&gt;    # by the prebuilt create_react_agent (supervisor)
&lt;span id=&#34;__span-8-16&#34;&gt;    return response.content
&lt;span id=&#34;__span-8-17&#34;&gt;
&lt;span id=&#34;__span-8-18&#34;&gt;def agent_2(state: Annotated[dict, InjectedState]):
&lt;span id=&#34;__span-8-19&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-8-20&#34;&gt;    return response.content
&lt;span id=&#34;__span-8-21&#34;&gt;
&lt;span id=&#34;__span-8-22&#34;&gt;tools = [agent_1, agent_2]
&lt;span id=&#34;__span-8-23&#34;&gt;# the simplest way to build a supervisor w/ tool-calling is to use prebuilt ReAct agent graph
&lt;span id=&#34;__span-8-24&#34;&gt;# that consists of a tool-calling LLM node (i.e. supervisor) and a tool-executing node
&lt;span id=&#34;__span-8-25&#34;&gt;supervisor = create_react_agent(model, tools)
</code></pre><h3 id="分层httpslanggraphcomcnconceptsmulti_agent1htmlhierarchical-永久链接">分层<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#hierarchical" title="永久链接">¶</a></h3>
<p>随着你向系统中添加更多代理，主管可能变得难以管理所有这些代理。主管可能开始在决定下一步调用哪个代理时做出糟糕的决策，或者上下文可能变得过于复杂，单个主管难以跟踪。换句话说，你最终会遇到最初促使多代理架构出现的问题。</p>
<p>为了解决这个问题，你可以_分层_设计你的系统。例如，你可以创建由单个主管管理的独立、专业化的代理团队，以及一个管理这些团队的顶层主管。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->ChatOpenAI<!-- raw HTML omitted --> | <!-- raw HTML omitted -->StateGraph<!-- raw HTML omitted --> | <!-- raw HTML omitted -->START<!-- raw HTML omitted --> | <!-- raw HTML omitted -->END<!-- raw HTML omitted --> | <!-- raw HTML omitted -->Command<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-9-1&#34;&gt;from typing import Literal
&lt;span id=&#34;__span-9-2&#34;&gt;from langchain_openai import ChatOpenAI
&lt;span id=&#34;__span-9-3&#34;&gt;from langgraph.graph import StateGraph, MessagesState, START, END
&lt;span id=&#34;__span-9-4&#34;&gt;from langgraph.types import Command
&lt;span id=&#34;__span-9-5&#34;&gt;model = ChatOpenAI()
&lt;span id=&#34;__span-9-6&#34;&gt;
&lt;span id=&#34;__span-9-7&#34;&gt;# define team 1 (same as the single supervisor example above)
&lt;span id=&#34;__span-9-8&#34;&gt;
&lt;span id=&#34;__span-9-9&#34;&gt;def team_1_supervisor(state: MessagesState) -&amp;gt; Command[Literal[&#34;team_1_agent_1&#34;, &#34;team_1_agent_2&#34;, END]]:
&lt;span id=&#34;__span-9-10&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-9-11&#34;&gt;    return Command(goto=response[&#34;next_agent&#34;])
&lt;span id=&#34;__span-9-12&#34;&gt;
&lt;span id=&#34;__span-9-13&#34;&gt;def team_1_agent_1(state: MessagesState) -&amp;gt; Command[Literal[&#34;team_1_supervisor&#34;]]:
&lt;span id=&#34;__span-9-14&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-9-15&#34;&gt;    return Command(goto=&#34;team_1_supervisor&#34;, update={&#34;messages&#34;: [response]})
&lt;span id=&#34;__span-9-16&#34;&gt;
&lt;span id=&#34;__span-9-17&#34;&gt;def team_1_agent_2(state: MessagesState) -&amp;gt; Command[Literal[&#34;team_1_supervisor&#34;]]:
&lt;span id=&#34;__span-9-18&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-9-19&#34;&gt;    return Command(goto=&#34;team_1_supervisor&#34;, update={&#34;messages&#34;: [response]})
&lt;span id=&#34;__span-9-20&#34;&gt;
&lt;span id=&#34;__span-9-21&#34;&gt;team_1_builder = StateGraph(Team1State)
&lt;span id=&#34;__span-9-22&#34;&gt;team_1_builder.add_node(team_1_supervisor)
&lt;span id=&#34;__span-9-23&#34;&gt;team_1_builder.add_node(team_1_agent_1)
&lt;span id=&#34;__span-9-24&#34;&gt;team_1_builder.add_node(team_1_agent_2)
&lt;span id=&#34;__span-9-25&#34;&gt;team_1_builder.add_edge(START, &#34;team_1_supervisor&#34;)
&lt;span id=&#34;__span-9-26&#34;&gt;team_1_graph = team_1_builder.compile()
&lt;span id=&#34;__span-9-27&#34;&gt;
&lt;span id=&#34;__span-9-28&#34;&gt;# define team 2 (same as the single supervisor example above)
&lt;span id=&#34;__span-9-29&#34;&gt;class Team2State(MessagesState):
&lt;span id=&#34;__span-9-30&#34;&gt;    next: Literal[&#34;team_2_agent_1&#34;, &#34;team_2_agent_2&#34;, &#34;__end__&#34;]
&lt;span id=&#34;__span-9-31&#34;&gt;
&lt;span id=&#34;__span-9-32&#34;&gt;def team_2_supervisor(state: Team2State):
&lt;span id=&#34;__span-9-33&#34;&gt;    ...
&lt;span id=&#34;__span-9-34&#34;&gt;
&lt;span id=&#34;__span-9-35&#34;&gt;def team_2_agent_1(state: Team2State):
&lt;span id=&#34;__span-9-36&#34;&gt;    ...
&lt;span id=&#34;__span-9-37&#34;&gt;
&lt;span id=&#34;__span-9-38&#34;&gt;def team_2_agent_2(state: Team2State):
&lt;span id=&#34;__span-9-39&#34;&gt;    ...
&lt;span id=&#34;__span-9-40&#34;&gt;
&lt;span id=&#34;__span-9-41&#34;&gt;team_2_builder = StateGraph(Team2State)
&lt;span id=&#34;__span-9-42&#34;&gt;...
&lt;span id=&#34;__span-9-43&#34;&gt;team_2_graph = team_2_builder.compile()
&lt;span id=&#34;__span-9-44&#34;&gt;
&lt;span id=&#34;__span-9-45&#34;&gt;
&lt;span id=&#34;__span-9-46&#34;&gt;# define top-level supervisor
&lt;span id=&#34;__span-9-47&#34;&gt;
&lt;span id=&#34;__span-9-48&#34;&gt;builder = StateGraph(MessagesState)
&lt;span id=&#34;__span-9-49&#34;&gt;def top_level_supervisor(state: MessagesState) -&amp;gt; Command[Literal[&#34;team_1_graph&#34;, &#34;team_2_graph&#34;, END]]:
&lt;span id=&#34;__span-9-50&#34;&gt;    # you can pass relevant parts of the state to the LLM (e.g., state[&#34;messages&#34;])
&lt;span id=&#34;__span-9-51&#34;&gt;    # to determine which team to call next. a common pattern is to call the model
&lt;span id=&#34;__span-9-52&#34;&gt;    # with a structured output (e.g. force it to return an output with a &#34;next_team&#34; field)
&lt;span id=&#34;__span-9-53&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-9-54&#34;&gt;    # route to one of the teams or exit based on the supervisor&#39;s decision
&lt;span id=&#34;__span-9-55&#34;&gt;    # if the supervisor returns &#34;__end__&#34;, the graph will finish execution
&lt;span id=&#34;__span-9-56&#34;&gt;    return Command(goto=response[&#34;next_team&#34;])
&lt;span id=&#34;__span-9-57&#34;&gt;
&lt;span id=&#34;__span-9-58&#34;&gt;builder = StateGraph(MessagesState)
&lt;span id=&#34;__span-9-59&#34;&gt;builder.add_node(top_level_supervisor)
&lt;span id=&#34;__span-9-60&#34;&gt;builder.add_node(&#34;team_1_graph&#34;, team_1_graph)
&lt;span id=&#34;__span-9-61&#34;&gt;builder.add_node(&#34;team_2_graph&#34;, team_2_graph)
&lt;span id=&#34;__span-9-62&#34;&gt;builder.add_edge(START, &#34;top_level_supervisor&#34;)
&lt;span id=&#34;__span-9-63&#34;&gt;builder.add_edge(&#34;team_1_graph&#34;, &#34;top_level_supervisor&#34;)
&lt;span id=&#34;__span-9-64&#34;&gt;builder.add_edge(&#34;team_2_graph&#34;, &#34;top_level_supervisor&#34;)
&lt;span id=&#34;__span-9-65&#34;&gt;graph = builder.compile()
</code></pre><h3 id="自定义多代理工作流httpslanggraphcomcnconceptsmulti_agent1htmlcustom-multi-agent-workflow-永久链接">自定义多代理工作流<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#custom-multi-agent-workflow" title="永久链接">¶</a></h3>
<p>在这种架构中，我们将单个代理作为图节点添加，并提前在自定义工作流中定义代理的调用顺序。在 LangGraph 中，工作流可以通过两种方式定义：</p>
<ul>
<li>
<p><strong>显式控制流（普通边）</strong>：LangGraph 允许你通过<a href="https://langgraph.com.cn/concepts/low_level.1.html#normal-edges">普通图边</a>显式定义应用程序的控制流（即代理如何通信的顺序）。这是上述架构中最确定性的变体——我们总是提前知道下一个将要调用的代理。</p>
</li>
<li>
<p><strong>动态控制流（Command）</strong>：在 LangGraph 中，你可以允许 LLM 决定应用程序控制流的部分。这可以通过使用<a href="https://langgraph.com.cn/concepts/low_level.1.html#command"><code>Command</code></a>来实现。一个特殊情况是<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#supervisor-tool-calling">主管工具调用</a>架构。在这种情况下，驱动主管代理的工具调用 LLM 将决定工具（代理）的调用顺序。</p>
</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->ChatOpenAI<!-- raw HTML omitted --> | <!-- raw HTML omitted -->StateGraph<!-- raw HTML omitted --> | <!-- raw HTML omitted -->START<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-10-1&#34;&gt;from langchain_openai import ChatOpenAI
&lt;span id=&#34;__span-10-2&#34;&gt;from langgraph.graph import StateGraph, MessagesState, START
&lt;span id=&#34;__span-10-3&#34;&gt;
&lt;span id=&#34;__span-10-4&#34;&gt;model = ChatOpenAI()
&lt;span id=&#34;__span-10-5&#34;&gt;
&lt;span id=&#34;__span-10-6&#34;&gt;def agent_1(state: MessagesState):
&lt;span id=&#34;__span-10-7&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-10-8&#34;&gt;    return {&#34;messages&#34;: [response]}
&lt;span id=&#34;__span-10-9&#34;&gt;
&lt;span id=&#34;__span-10-10&#34;&gt;def agent_2(state: MessagesState):
&lt;span id=&#34;__span-10-11&#34;&gt;    response = model.invoke(...)
&lt;span id=&#34;__span-10-12&#34;&gt;    return {&#34;messages&#34;: [response]}
&lt;span id=&#34;__span-10-13&#34;&gt;
&lt;span id=&#34;__span-10-14&#34;&gt;builder = StateGraph(MessagesState)
&lt;span id=&#34;__span-10-15&#34;&gt;builder.add_node(agent_1)
&lt;span id=&#34;__span-10-16&#34;&gt;builder.add_node(agent_2)
&lt;span id=&#34;__span-10-17&#34;&gt;# define the flow explicitly
&lt;span id=&#34;__span-10-18&#34;&gt;builder.add_edge(START, &#34;agent_1&#34;)
&lt;span id=&#34;__span-10-19&#34;&gt;builder.add_edge(&#34;agent_1&#34;, &#34;agent_2&#34;)
</code></pre><h2 id="通信与状态管理httpslanggraphcomcnconceptsmulti_agent1htmlcommunication-and-state-management-永久链接">通信与状态管理<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#communication-and-state-management" title="永久链接">¶</a></h2>
<p>构建多代理系统时最重要的事情是弄清楚代理如何通信。</p>
<p>代理之间通信的一种常见、通用的方式是通过消息列表。这引出了以下问题：</p>
<ul>
<li>代理是通过<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs-vs-tool-calls"><strong>交接还是工具调用</strong></a>进行通信？</li>
<li>哪些消息<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#message-passing-between-agents"><strong>从一个代理传递到下一个代理</strong></a>？</li>
<li>在<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#representing-handoffs-in-message-history"><strong>消息列表中如何表示交接</strong></a>？</li>
<li>你如何<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#state-management-for-subagents"><strong>管理子代理的状态</strong></a>？</li>
</ul>
<p>此外，如果你正在处理更复杂的代理或希望将单个代理状态与多代理系统状态分开，你可能需要使用<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#using-different-state-schemas"><strong>不同的状态模式</strong></a>。</p>
<h3 id="交接与工具调用httpslanggraphcomcnconceptsmulti_agent1htmlhandoffs-vs-tool-calls-永久链接">交接与工具调用<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs-vs-tool-calls" title="永久链接">¶</a></h3>
<p>在代理之间传递的“有效载荷”是什么？在上述大多数架构中，代理通过<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs">交接</a>进行通信，并将<a href="https://langgraph.com.cn/concepts/low_level.1.html#state">图状态</a>作为交接有效载荷的一部分进行传递。具体来说，代理将消息列表作为图状态的一部分传递。在<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#supervisor-tool-calling">带有工具调用的主管</a>的情况下，有效载荷是工具调用参数。</p>
<p>
        <img class="mx-auto" alt="" src="https://api.995120.cn/ecgdata/other/2026-01-08/2578620260108160857rPxWBbfT.png" />   
    </p>
<h3 id="代理间的消息传递httpslanggraphcomcnconceptsmulti_agent1htmlmessage-passing-between-agents-永久链接">代理间的消息传递<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#message-passing-between-agents" title="永久链接">¶</a></h3>
<p>代理之间最常见的通信方式是通过共享状态通道，通常是消息列表。这假设状态中总是有至少一个代理共享的通道（键）（例如，<code>messages</code>）。当通过共享消息列表进行通信时，还有一个额外的考虑：代理应该<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#sharing-full-thought-process">共享其思维过程的完整历史</a>还是只<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#sharing-only-final-results">共享最终结果</a>？</p>
<p>
        <img class="mx-auto" alt="" src="https://api.995120.cn/ecgdata/other/2026-01-08/2995220260108160858EbcVeVcx.png" />   
    </p>
<h4 id="共享完整思维过程httpslanggraphcomcnconceptsmulti_agent1htmlsharing-full-thought-process-永久链接">共享完整思维过程<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#sharing-full-thought-process" title="永久链接">¶</a></h4>
<p>代理可以与所有其他代理<strong>共享其思维过程的完整历史</strong>（即，“草稿本”）。这个“草稿本”通常看起来像一个<a href="https://langgraph.com.cn/concepts/low_level.1.html#why-use-messages">消息列表</a>。共享完整思维过程的好处是，它可能帮助其他代理做出更好的决策，并提高整个系统的推理能力。缺点是，随着代理数量和复杂性的增长，“草稿本”将迅速增长，可能需要额外的<a href="https://langgraph.com.cn/concepts/memory.1.html#managing-long-conversation-history">内存管理</a>策略。</p>
<h4 id="只共享最终结果httpslanggraphcomcnconceptsmulti_agent1htmlsharing-only-final-results-永久链接">只共享最终结果<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#sharing-only-final-results" title="永久链接">¶</a></h4>
<p>代理可以拥有自己的私有“草稿本”，并且只与其余代理<strong>共享最终结果</strong>。这种方法可能更适用于具有许多代理或更复杂的代理的系统。在这种情况下，你需要定义具有<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#using-different-state-schemas">不同状态模式</a>的代理。</p>
<p>对于作为工具调用的代理，主管根据工具模式确定输入。此外，LangGraph 允许在运行时<a href="https://langgraph.com.cn/how-tos/tool-calling.1.html#read-state">将状态传递</a>给单个工具，因此下属代理可以在需要时访问父状态。</p>
<h4 id="在消息中指示代理名称httpslanggraphcomcnconceptsmulti_agent1htmlindicating-agent-name-in-messages-永久链接">在消息中指示代理名称<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#indicating-agent-name-in-messages" title="永久链接">¶</a></h4>
<p>在消息中指示特定 AI 消息来自哪个代理会很有帮助，特别是对于冗长的消息历史。一些 LLM 提供商（如 OpenAI）支持向消息添加 <code>name</code> 参数——你可以使用它将代理名称附加到消息中。如果不支持，你可以考虑手动将代理名称注入到消息内容中，例如，<code>&lt;agent&gt;alice&lt;/agent&gt;&lt;message&gt;来自 alice 的消息&lt;/message&gt;</code>。</p>
<h3 id="在消息历史中表示交接httpslanggraphcomcnconceptsmulti_agent1htmlrepresenting-handoffs-in-message-history-永久链接">在消息历史中表示交接<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#representing-handoffs-in-message-history" title="永久链接">¶</a></h3>
<p>交接通常通过 LLM 调用专用的<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs-as-tools">交接工具</a>来完成。这表示为带有工具调用的<a href="https://python.langchain.ac.cn/docs/concepts/messages/#aimessage">AI 消息</a>，并传递给下一个代理（LLM）。大多数 LLM 提供商不支持接收带有工具调用的 AI 消息，<strong>而没有</strong>相应的工具消息。</p>
<p>因此你有两种选择：</p>
<ol>
<li>在消息列表中添加额外的<a href="https://python.langchain.ac.cn/docs/concepts/messages/#toolmessage">工具消息</a>，例如，“已成功转移到代理 X”</li>
<li>移除带有工具调用的 AI 消息</li>
</ol>
<p>实际上，我们发现大多数开发者选择选项 (1)。</p>
<h3 id="子代理的状态管理httpslanggraphcomcnconceptsmulti_agent1htmlstate-management-for-subagents-永久链接">子代理的状态管理<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#state-management-for-subagents" title="永久链接">¶</a></h3>
<p>一种常见的做法是让多个代理在共享消息列表上通信，但只<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#sharing-only-final-results">将它们的最终消息添加到列表中</a>。这意味着任何中间消息（例如，工具调用）都不会保存在此列表中。</p>
<p>如果你<strong>确实</strong>想保存这些消息，以便如果将来调用此特定子代理，你可以将这些消息传回，该怎么办？</p>
<p>有两种高级方法可以实现这一点：</p>
<ol>
<li>将这些消息存储在共享消息列表中，但在将列表传递给子代理 LLM 之前对其进行过滤。例如，你可以选择过滤掉来自<strong>其他</strong>代理的所有工具调用。</li>
<li>在子代理的图状态中为每个代理存储一个单独的消息列表（例如，<code>alice_messages</code>）。这将是它们对消息历史的“视图”。</li>
</ol>
<h3 id="使用不同的状态模式httpslanggraphcomcnconceptsmulti_agent1htmlusing-different-state-schemas-永久链接">使用不同的状态模式<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#using-different-state-schemas" title="永久链接">¶</a></h3>
<p>一个代理可能需要与其余代理有不同的状态模式。例如，一个搜索代理可能只需要跟踪查询和检索到的文档。在 LangGraph 中有两种方法可以实现这一点：</p>
<ul>
<li>使用单独的状态模式定义<a href="https://langgraph.com.cn/concepts/subgraphs.1.html">子图</a>代理。如果子图和父图之间没有共享状态键（通道），则重要的是<a href="https://langgraph.com.cn/how-tos/subgraph/index.html#different-state-schemas">添加输入/输出转换</a>，以便父图知道如何与子图通信。</li>
<li>使用<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#pass-private-state-between-nodes">私有输入状态模式</a>定义代理节点函数，该模式与整个图状态模式不同。这允许传递仅用于执行特定代理的信息。</li>
</ul>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://index.zshipu.com/ai002">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://index.zshipu.com/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-9/">https://index.zshipu.com/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-9/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-8/">概述 - LangChain 框架 (8) --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-7/">概述 - LangChain 框架 (7) --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-6/">概述 - LangChain 框架 (6) --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-5/">概述 - LangChain 框架 (5) --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-4/">概述 - LangChain 框架 (4) --知识铺</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            没有标签
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-index"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2026 <a href="https://index.zshipu.com/ai002">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/ai002/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://index.zshipu.com/ai002/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://index.zshipu.com/ai002">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/agentskillsagentskills-Agent-Skills-%E7%9A%84%E8%A7%84%E8%8C%83%E5%92%8C%E6%96%87%E6%A1%A3---agentskillsagentskills-Specification-and-documentation-for-Agent-Skills/" title="agentskillsagentskills Agent Skills 的规范和文档 --- agentskillsagentskills Specification and documentation for Agent Skills --知识铺">agentskillsagentskills Agent Skills 的规范和文档 --- agentskillsagentskills Specification and documentation for Agent Skills --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/2026%E5%B9%B4AI%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Agent-Skill%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%8A%AB%E9%9C%B2%E6%9E%B6%E6%9E%84%E4%BC%81%E4%B8%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Agent-Skill%E4%B8%BA%E9%80%9A%E7%94%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%85%8D%E5%A4%87%E7%B2%BE%E5%87%86%E7%9A%84%E5%B2%97%E4%BD%8DSOP-%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA-%E8%85%BE%E8%AE%AF%E4%BA%91/" title="2026年AI应用技术栈：深度剖析Agent Skill“渐进式披露”架构！企业如何利用Agent Skill，为通用大模型配备精准的“岗位SOP”？-腾讯云开发者社区-腾讯云 --知识铺">2026年AI应用技术栈：深度剖析Agent Skill“渐进式披露”架构！企业如何利用Agent Skill，为通用大模型配备精准的“岗位SOP”？-腾讯云开发者社区-腾讯云 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E5%BF%85%E8%97%8F%E5%B9%B2%E8%B4%A7%E5%A4%A7%E6%A8%A1%E5%9E%8BAgent%E6%8A%80%E8%83%BD%E5%8C%85Agent-Skills%E6%A0%87%E5%87%86%E5%8C%96%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%E8%AE%A9AI%E5%BC%80%E5%8F%91%E5%83%8F%E6%90%AD%E7%A7%AF%E6%9C%A8%E4%B8%80%E6%A0%B7%E7%AE%80%E5%8D%95-CSDN%E5%8D%9A%E5%AE%A2/" title="【必藏干货】大模型Agent技能包：Agent Skills标准化框架详解，让AI开发像搭积木一样简单-CSDN博客 --知识铺">【必藏干货】大模型Agent技能包：Agent Skills标准化框架详解，让AI开发像搭积木一样简单-CSDN博客 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/Agent-Skills-%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97%E5%85%A5%E9%97%A8%E7%B2%BE%E9%80%9A%E9%A2%84%E6%B5%8B-%E7%9F%A5%E4%B9%8E/" title="Agent Skills 终极指南：入门、精通、预测 - 知乎 --知识铺">Agent Skills 终极指南：入门、精通、预测 - 知乎 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E9%AA%97%E4%BD%A0%E7%9A%84%E5%85%B6%E5%AE%9EAI%E6%A0%B9%E6%9C%AC%E4%B8%8D%E9%9C%80%E8%A6%81%E9%82%A3%E4%B9%88%E5%A4%9A%E6%8F%90%E7%A4%BA%E8%AF%8DAI_%E6%96%B0%E6%B5%AA%E7%A7%91%E6%8A%80_%E6%96%B0%E6%B5%AA%E7%BD%91/" title="骗你的！其实AI根本不需要那么多提示词AI_新浪科技_新浪网 --知识铺">骗你的！其实AI根本不需要那么多提示词AI_新浪科技_新浪网 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F%E7%9A%84%E7%94%A8-Claude-Code-%E5%B8%AE%E4%BD%A0%E5%88%9B%E5%BB%BA-PPT-%E7%94%9F%E6%88%90-Skills_%E8%85%BE%E8%AE%AF%E6%96%B0%E9%97%BB/" title="简单快速的用 Claude Code 帮你创建 PPT 生成 Skills_腾讯新闻 --知识铺">简单快速的用 Claude Code 帮你创建 PPT 生成 Skills_腾讯新闻 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/Skills%E5%B0%B1%E6%98%AF%E7%BB%99AI%E7%94%A8%E7%9A%84APP-302.AI%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%E4%B8%80%E8%81%8A-/" title="Skills就是给AI用的APP  302.AI大白话聊一聊 - --知识铺">Skills就是给AI用的APP  302.AI大白话聊一聊 - --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E7%BB%99AI%E8%A3%85%E4%B8%AA%E6%8A%80%E8%83%BD%E5%8C%85Skills%E6%98%AF%E4%BB%80%E4%B9%88_%E8%85%BE%E8%AE%AF%E6%96%B0%E9%97%BB/" title="给AI装个技能包：Skills是什么_腾讯新闻 --知识铺">给AI装个技能包：Skills是什么_腾讯新闻 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/Skills%E7%9A%84%E5%AE%B9%E9%87%8F%E4%B8%8A%E9%99%90%E5%9C%A8%E5%93%AA%E9%87%8C2026%E5%8D%95Skills%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E5%A4%9AAgent%E5%A5%BDUCB%E6%9C%80%E6%96%B0_%E8%85%BE%E8%AE%AF%E6%96%B0%E9%97%BB/" title="Skills的容量上限在哪里？2026单Skills组合还是多Agent好？｜UCB最新_腾讯新闻 --知识铺">Skills的容量上限在哪里？2026单Skills组合还是多Agent好？｜UCB最新_腾讯新闻 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E6%9C%80%E8%BF%91%E8%81%8A%E7%88%86%E7%9A%84Skills-%E5%88%B0%E5%BA%95%E6%98%AF%E5%95%A5%E8%AF%B7%E7%94%A8%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AF%9D%E5%91%8A%E8%AF%89%E6%88%91-%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/" title="最近聊爆的Skills 到底是啥？请用通俗易懂的话告诉我  人人都是产品经理 --知识铺">最近聊爆的Skills 到底是啥？请用通俗易懂的话告诉我  人人都是产品经理 --知识铺</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利派送</h3>
    <ul class="widget-list">
        
        <li>
            <a href="https://pplx.ai/sblig3912" title="一起上 Comet，AI 工具免费用还送钱～" target="_blank" style="color:red">
                
                    <img src="https://cdn.jsdelivr.net/gh/zshipu/images/2025/202510250843697.png">
                
            </a>
        </li>
        
        <li>
            <a href="https://pplx.ai/sblig3912" title="邀请有礼 🎁 一起用 Comet，AI 助你更高效还送钱！" target="_blank" style="color:red">
                
                    <img src="https://cdn.jsdelivr.net/gh/zshipu/images/2025/202510250850822.png">
                
            </a>
        </li>
        
        <li>
            <a href="https://pplx.ai/sblig3912" title="AI 工具真香！我用的 Comet 免费送一个月 Pro～" target="_blank" style="color:red">
                
                    <img src="https://cdn.jsdelivr.net/gh/zshipu/images/2025/202510250851688.png">
                
            </a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title"><a href='/ai002/categories/'>分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/ai002/tags/'>标签</a></h3>
<div class="tagcloud">
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://index.zshipu.com/ai002/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>