<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>概述 - LangChain 框架 (2) --知识铺 | 知识铺的博客</title>
    <meta property="og:title" content="概述 - LangChain 框架 (2) --知识铺 - 知识铺的博客">
    <meta property="og:type" content="article">
    
    <meta property="article:published_time" content='2026-01-08T09:00:08&#43;08:00'>
    
    
    <meta property="article:modified_time" content='2026-01-08T09:00:08&#43;08:00'>
    
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="概述 - LangChain 框架 (2) --知识铺">
    
    <meta name="author" content="知识铺">
    <meta property="og:url" content="https://index.zshipu.com/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-2/">
    <link rel="shortcut icon" href='/ai002/favicon.ico' type="image/x-icon">

    <link rel="stylesheet" href='/ai002/css/normalize.css'>
    <link rel="stylesheet" href='/ai002/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    

    

    
    
    
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-WLWJSST');</script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BY5XJ2PJ93"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-BY5XJ2PJ93');
    </script>
    
</head>

<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://index.zshipu.com/ai002">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://index.zshipu.com/ai002">首页</a>
                    
                    <a  href="https://index.zshipu.com/ai001/" title="AI技术">AI技术</a>
                    
                    <a  href="https://index.zshipu.com" title="总站">总站</a>
                    
                    <a  href="https://index.zshipu.com/ai002/archives/" title="归档">归档</a>
                    
                    <a  href="https://index.zshipu.com/ai002/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#图-api-概念httpslanggraphcomcnconceptslow_level1htmlgraph-api-concepts-permanent-link">图 API 概念<a href="https://langgraph.com.cn/concepts/low_level.1.html#graph-api-concepts" title="Permanent link">¶</a></a></li>
    <li><a href="#图httpslanggraphcomcnconceptslow_level1htmlgraphs-permanent-link">图<a href="https://langgraph.com.cn/concepts/low_level.1.html#graphs" title="Permanent link">¶</a></a>
      <ul>
        <li><a href="#stategraphhttpslanggraphcomcnconceptslow_level1htmlstategraph-permanent-link">StateGraph<a href="https://langgraph.com.cn/concepts/low_level.1.html#stategraph" title="Permanent link">¶</a></a></li>
        <li><a href="#编译图httpslanggraphcomcnconceptslow_level1htmlcompiling-your-graph-permanent-link">编译图<a href="https://langgraph.com.cn/concepts/low_level.1.html#compiling-your-graph" title="Permanent link">¶</a></a></li>
      </ul>
    </li>
    <li><a href="#状态httpslanggraphcomcnconceptslow_level1htmlstate-permanent-link">状态<a href="https://langgraph.com.cn/concepts/low_level.1.html#state" title="Permanent link">¶</a></a>
      <ul>
        <li><a href="#模式httpslanggraphcomcnconceptslow_level1htmlschema-permanent-link">模式<a href="https://langgraph.com.cn/concepts/low_level.1.html#schema" title="Permanent link">¶</a></a></li>
        <li><a href="#归约器httpslanggraphcomcnconceptslow_level1htmlreducers-permanent-link">归约器<a href="https://langgraph.com.cn/concepts/low_level.1.html#reducers" title="Permanent link">¶</a></a></li>
        <li><a href="#在图状态中使用消息httpslanggraphcomcnconceptslow_level1htmlworking-with-messages-in-graph-state-permanent-link">在图状态中使用消息<a href="https://langgraph.com.cn/concepts/low_level.1.html#working-with-messages-in-graph-state" title="Permanent link">¶</a></a></li>
      </ul>
    </li>
    <li><a href="#节点httpslanggraphcomcnconceptslow_level1htmlnodes-permanent-link">节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#nodes" title="Permanent link">¶</a></a>
      <ul>
        <li><a href="#start-节点httpslanggraphcomcnconceptslow_level1htmlstart-node-permanent-link"><code>START</code> 节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#start-node" title="Permanent link">¶</a></a></li>
        <li><a href="#end-节点httpslanggraphcomcnconceptslow_level1htmlend-node-permanent-link"><code>END</code> 节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#end-node" title="Permanent link">¶</a></a></li>
        <li><a href="#节点缓存httpslanggraphcomcnconceptslow_level1htmlnode-caching-permanent-link">节点缓存<a href="https://langgraph.com.cn/concepts/low_level.1.html#node-caching" title="Permanent link">¶</a></a></li>
      </ul>
    </li>
    <li><a href="#边httpslanggraphcomcnconceptslow_level1htmledges-permanent-link">边<a href="https://langgraph.com.cn/concepts/low_level.1.html#edges" title="Permanent link">¶</a></a>
      <ul>
        <li><a href="#普通边httpslanggraphcomcnconceptslow_level1htmlnormal-edges-permanent-link">普通边<a href="https://langgraph.com.cn/concepts/low_level.1.html#normal-edges" title="Permanent link">¶</a></a></li>
        <li><a href="#条件边httpslanggraphcomcnconceptslow_level1htmlconditional-edges-permanent-link">条件边<a href="https://langgraph.com.cn/concepts/low_level.1.html#conditional-edges" title="Permanent link">¶</a></a></li>
        <li><a href="#入口点httpslanggraphcomcnconceptslow_level1htmlentry-point-permanent-link">入口点<a href="https://langgraph.com.cn/concepts/low_level.1.html#entry-point" title="Permanent link">¶</a></a></li>
        <li><a href="#条件入口点httpslanggraphcomcnconceptslow_level1htmlconditional-entry-point-permanent-link">条件入口点<a href="https://langgraph.com.cn/concepts/low_level.1.html#conditional-entry-point" title="Permanent link">¶</a></a></li>
      </ul>
    </li>
    <li><a href="#sendhttpslanggraphcomcnconceptslow_level1htmlsend-permanent-link"><code>Send</code><a href="https://langgraph.com.cn/concepts/low_level.1.html#send" title="Permanent link">¶</a></a></li>
    <li><a href="#commandhttpslanggraphcomcnconceptslow_level1htmlcommand-permanent-link"><code>Command</code><a href="https://langgraph.com.cn/concepts/low_level.1.html#command" title="Permanent link">¶</a></a>
      <ul>
        <li><a href="#什么时候应该使用-command-而不是条件边httpslanggraphcomcnconceptslow_level1htmlwhen-should-i-use-command-instead-of-conditional-edges-permanent-link">什么时候应该使用 Command 而不是条件边？<a href="https://langgraph.com.cn/concepts/low_level.1.html#when-should-i-use-command-instead-of-conditional-edges" title="Permanent link">¶</a></a></li>
        <li><a href="#导航到父图中的节点httpslanggraphcomcnconceptslow_level1htmlnavigating-to-a-node-in-a-parent-graph-permanent-link">导航到父图中的节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#navigating-to-a-node-in-a-parent-graph" title="Permanent link">¶</a></a></li>
        <li><a href="#在工具内部使用httpslanggraphcomcnconceptslow_level1htmlusing-inside-tools-permanent-link">在工具内部使用<a href="https://langgraph.com.cn/concepts/low_level.1.html#using-inside-tools" title="Permanent link">¶</a></a></li>
        <li><a href="#人工参与httpslanggraphcomcnconceptslow_level1htmlhuman-in-the-loop-permanent-link">人工参与<a href="https://langgraph.com.cn/concepts/low_level.1.html#human-in-the-loop" title="Permanent link">¶</a></a></li>
      </ul>
    </li>
    <li><a href="#图迁移httpslanggraphcomcnconceptslow_level1htmlgraph-migrations-permanent-link">图迁移<a href="https://langgraph.com.cn/concepts/low_level.1.html#graph-migrations" title="Permanent link">¶</a></a></li>
    <li><a href="#配置httpslanggraphcomcnconceptslow_level1htmlconfiguration-permanent-link">配置<a href="https://langgraph.com.cn/concepts/low_level.1.html#configuration" title="Permanent link">¶</a></a>
      <ul>
        <li><a href="#递归限制httpslanggraphcomcnconceptslow_level1htmlrecursion-limit-permanent-link">递归限制<a href="https://langgraph.com.cn/concepts/low_level.1.html#recursion-limit" title="Permanent link">¶</a></a></li>
      </ul>
    </li>
    <li><a href="#可视化httpslanggraphcomcnconceptslow_level1htmlvisualization-permanent-link">可视化<a href="https://langgraph.com.cn/concepts/low_level.1.html#visualization" title="Permanent link">¶</a></a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">概述 - LangChain 框架 (2) --知识铺</h1>
        </header>
        <date class="post-meta meta-date">
            2026年1月8日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <p><a href="https://github.com/langchain-ai/langgraph/edit/main/docs/docs/concepts/low_level.md" title="Edit this page"></a></p>
<h2 id="图-api-概念httpslanggraphcomcnconceptslow_level1htmlgraph-api-concepts-permanent-link">图 API 概念<a href="https://langgraph.com.cn/concepts/low_level.1.html#graph-api-concepts" title="Permanent link">¶</a></h2>
<h2 id="图httpslanggraphcomcnconceptslow_level1htmlgraphs-permanent-link">图<a href="https://langgraph.com.cn/concepts/low_level.1.html#graphs" title="Permanent link">¶</a></h2>
<p>LangGraph 的核心是将代理工作流建模为图。您可以使用三个关键组件来定义代理的行为：</p>
<ol>
<li>
<p><a href="https://langgraph.com.cn/concepts/low_level.1.html#state"><code>State</code></a>：一个共享数据结构，表示应用程序的当前快照。它可以是任何 Python 类型，但通常是 <code>TypedDict</code> 或 Pydantic <code>BaseModel</code>。</p>
</li>
<li>
<p><a href="https://langgraph.com.cn/concepts/low_level.1.html#nodes"><code>Nodes</code></a>：编码代理逻辑的 Python 函数。它们接收当前的 <code>State</code> 作为输入，执行一些计算或副作用，并返回一个更新的 <code>State</code>。</p>
</li>
<li>
<p><a href="https://langgraph.com.cn/concepts/low_level.1.html#edges"><code>Edges</code></a>：Python 函数，根据当前的 <code>State</code> 决定接下来执行哪个 <code>Node</code>。它们可以是条件分支或固定转换。</p>
</li>
</ol>
<p>通过组合 <code>Nodes</code> 和 <code>Edges</code>，您可以创建复杂、循环的工作流，使 <code>State</code> 随时间演进。然而，真正的力量来自于 LangGraph 如何管理 <code>State</code>。需要强调的是：<code>Nodes</code> 和 <code>Edges</code> 不过是 Python 函数——它们可以包含一个 LLM，也可以只是普通的 Python 代码。</p>
<p>简而言之：<em>节点完成工作，边指示下一步该做什么</em>。</p>
<p>LangGraph 的底层图算法使用<a href="https://en.wikipedia.org/wiki/Message_passing">消息传递</a>来定义通用程序。当一个节点完成其操作时，它会沿着一条或多条边向其他节点发送消息。这些接收节点随后执行其函数，将结果消息传递给下一组节点，然后该过程继续。受 Google 的 <a href="https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/">Pregel</a> 系统启发，程序以离散的“超步”进行。</p>
<p>超步可以被认为是图节点的一次迭代。并行运行的节点属于同一个超步，而顺序运行的节点属于不同的超步。在图执行开始时，所有节点都处于 <code>inactive</code> 状态。当节点在其任何传入边（或“通道”）上接收到新消息（状态）时，它就会变为 <code>active</code>。活跃节点随后运行其函数并返回更新。在每个超步结束时，没有传入消息的节点通过将自身标记为 <code>inactive</code> 来投票 <code>halt</code>（停止）。当所有节点都处于 <code>inactive</code> 状态且没有消息传输时，图执行终止。</p>
<h3 id="stategraphhttpslanggraphcomcnconceptslow_level1htmlstategraph-permanent-link">StateGraph<a href="https://langgraph.com.cn/concepts/low_level.1.html#stategraph" title="Permanent link">¶</a></h3>
<p><code>StateGraph</code> 类是主要的图类。它通过用户定义的 <code>State</code> 对象进行参数化。</p>
<h3 id="编译图httpslanggraphcomcnconceptslow_level1htmlcompiling-your-graph-permanent-link">编译图<a href="https://langgraph.com.cn/concepts/low_level.1.html#compiling-your-graph" title="Permanent link">¶</a></h3>
<p>要构建图，您首先定义<a href="https://langgraph.com.cn/concepts/low_level.1.html#state">状态</a>，然后添加<a href="https://langgraph.com.cn/concepts/low_level.1.html#nodes">节点</a>和<a href="https://langgraph.com.cn/concepts/low_level.1.html#edges">边</a>，最后编译它。究竟什么是编译图，为什么需要它？</p>
<p>编译是一个相当简单的步骤。它对图的结构进行一些基本检查（例如，没有孤立节点）。它也是您可以指定运行时参数的地方，例如<a href="https://langgraph.com.cn/concepts/persistence.1.html">检查点</a>和断点。您只需调用 <code>.compile</code> 方法即可编译图。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-0-1&#34;&gt;graph = graph_builder.compile(...)
</code></pre><p>您<strong>必须</strong>先编译图才能使用它。</p>
<h2 id="状态httpslanggraphcomcnconceptslow_level1htmlstate-permanent-link">状态<a href="https://langgraph.com.cn/concepts/low_level.1.html#state" title="Permanent link">¶</a></h2>
<p>定义图时，您要做的第一件事是定义图的 <code>State</code>。<code>State</code> 包含<a href="https://langgraph.com.cn/concepts/low_level.1.html#schema">图的模式</a>以及指定如何应用状态更新的<a href="https://langgraph.com.cn/concepts/low_level.1.html#reducers"><code>reducer</code> 函数</a>。<code>State</code> 的模式将是图中所有 <code>Nodes</code> 和 <code>Edges</code> 的输入模式，可以是 <code>TypedDict</code> 或 <code>Pydantic</code> 模型。所有 <code>Nodes</code> 都将发出对 <code>State</code> 的更新，然后使用指定的 <code>reducer</code> 函数应用这些更新。</p>
<h3 id="模式httpslanggraphcomcnconceptslow_level1htmlschema-permanent-link">模式<a href="https://langgraph.com.cn/concepts/low_level.1.html#schema" title="Permanent link">¶</a></h3>
<p>指定图模式的主要文档化方法是使用 <code>TypedDict</code>。然而，我们也支持<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#use-pydantic-models-for-graph-state">使用 Pydantic BaseModel</a> 作为图状态，以添加<strong>默认值</strong>和额外的数据验证。</p>
<p>默认情况下，图将具有相同的输入和输出模式。如果您想更改此设置，您还可以直接指定显式的输入和输出模式。当您有许多键，并且有些键专门用于输入而另一些用于输出时，这会很有用。有关如何使用的信息，请参阅<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#define-input-and-output-schemas">此处指南</a>。</p>
<h4 id="多个模式httpslanggraphcomcnconceptslow_level1htmlmultiple-schemas-permanent-link">多个模式<a href="https://langgraph.com.cn/concepts/low_level.1.html#multiple-schemas" title="Permanent link">¶</a></h4>
<p>通常，所有图节点都使用单个模式进行通信。这意味着它们将读写相同的状态通道。但是，在某些情况下，我们希望对此有更多控制：</p>
<ul>
<li>内部节点可以传递图中输入/输出不需要的信息。</li>
<li>我们可能还希望为图使用不同的输入/输出模式。例如，输出可能只包含一个相关的输出键。</li>
</ul>
<p>节点可以在图内部写入私有状态通道以进行内部节点通信。我们可以简单地定义一个私有模式 <code>PrivateState</code>。有关更多详细信息，请参阅<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#pass-private-state-between-nodes">本指南</a>。</p>
<p>还可以为图定义显式输入和输出模式。在这些情况下，我们定义一个包含与图操作相关的_所有_键的“内部”模式。但是，我们也定义 <code>input</code> 和 <code>output</code> 模式，它们是“内部”模式的子集，用于约束图的输入和输出。有关更多详细信息，请参阅<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#define-input-and-output-schemas">本指南</a>。</p>
<p>让我们看一个例子</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-1-1&#34;&gt;class InputState(TypedDict):
&lt;span id=&#34;__span-1-2&#34;&gt;    user_input: str
&lt;span id=&#34;__span-1-3&#34;&gt;
&lt;span id=&#34;__span-1-4&#34;&gt;class OutputState(TypedDict):
&lt;span id=&#34;__span-1-5&#34;&gt;    graph_output: str
&lt;span id=&#34;__span-1-6&#34;&gt;
&lt;span id=&#34;__span-1-7&#34;&gt;class OverallState(TypedDict):
&lt;span id=&#34;__span-1-8&#34;&gt;    foo: str
&lt;span id=&#34;__span-1-9&#34;&gt;    user_input: str
&lt;span id=&#34;__span-1-10&#34;&gt;    graph_output: str
&lt;span id=&#34;__span-1-11&#34;&gt;
&lt;span id=&#34;__span-1-12&#34;&gt;class PrivateState(TypedDict):
&lt;span id=&#34;__span-1-13&#34;&gt;    bar: str
&lt;span id=&#34;__span-1-14&#34;&gt;
&lt;span id=&#34;__span-1-15&#34;&gt;def node_1(state: InputState) -&amp;gt; OverallState:
&lt;span id=&#34;__span-1-16&#34;&gt;    # Write to OverallState
&lt;span id=&#34;__span-1-17&#34;&gt;    return {&#34;foo&#34;: state[&#34;user_input&#34;] + &#34; name&#34;}
&lt;span id=&#34;__span-1-18&#34;&gt;
&lt;span id=&#34;__span-1-19&#34;&gt;def node_2(state: OverallState) -&amp;gt; PrivateState:
&lt;span id=&#34;__span-1-20&#34;&gt;    # Read from OverallState, write to PrivateState
&lt;span id=&#34;__span-1-21&#34;&gt;    return {&#34;bar&#34;: state[&#34;foo&#34;] + &#34; is&#34;}
&lt;span id=&#34;__span-1-22&#34;&gt;
&lt;span id=&#34;__span-1-23&#34;&gt;def node_3(state: PrivateState) -&amp;gt; OutputState:
&lt;span id=&#34;__span-1-24&#34;&gt;    # Read from PrivateState, write to OutputState
&lt;span id=&#34;__span-1-25&#34;&gt;    return {&#34;graph_output&#34;: state[&#34;bar&#34;] + &#34; Lance&#34;}
&lt;span id=&#34;__span-1-26&#34;&gt;
&lt;span id=&#34;__span-1-27&#34;&gt;builder = StateGraph(OverallState,input=InputState,output=OutputState)
&lt;span id=&#34;__span-1-28&#34;&gt;builder.add_node(&#34;node_1&#34;, node_1)
&lt;span id=&#34;__span-1-29&#34;&gt;builder.add_node(&#34;node_2&#34;, node_2)
&lt;span id=&#34;__span-1-30&#34;&gt;builder.add_node(&#34;node_3&#34;, node_3)
&lt;span id=&#34;__span-1-31&#34;&gt;builder.add_edge(START, &#34;node_1&#34;)
&lt;span id=&#34;__span-1-32&#34;&gt;builder.add_edge(&#34;node_1&#34;, &#34;node_2&#34;)
&lt;span id=&#34;__span-1-33&#34;&gt;builder.add_edge(&#34;node_2&#34;, &#34;node_3&#34;)
&lt;span id=&#34;__span-1-34&#34;&gt;builder.add_edge(&#34;node_3&#34;, END)
&lt;span id=&#34;__span-1-35&#34;&gt;
&lt;span id=&#34;__span-1-36&#34;&gt;graph = builder.compile()
&lt;span id=&#34;__span-1-37&#34;&gt;graph.invoke({&#34;user_input&#34;:&#34;My&#34;})
&lt;span id=&#34;__span-1-38&#34;&gt;{&#39;graph_output&#39;: &#39;My name is Lance&#39;}
</code></pre><p>这里有两点微妙而重要的注意事项：</p>
<ol>
<li>
<p>我们将 <code>state: InputState</code> 作为输入模式传递给 <code>node_1</code>。但是，我们写入 <code>OverallState</code> 中的通道 <code>foo</code>。我们如何写入一个不包含在输入模式中的状态通道？这是因为节点_可以写入图状态中的任何状态通道_。图状态是初始化时定义的所有状态通道的并集，其中包括 <code>OverallState</code> 以及筛选器 <code>InputState</code> 和 <code>OutputState</code>。</p>
</li>
<li>
<p>我们使用 <code>StateGraph(OverallState,input=InputState,output=OutputState)</code> 初始化图。那么，我们如何在 <code>node_2</code> 中写入 <code>PrivateState</code> 呢？如果未在 <code>StateGraph</code> 初始化中传递此模式，图如何访问它？我们可以这样做，因为_节点也可以声明额外的状态通道_，只要状态模式定义存在即可。在这种情况下，<code>PrivateState</code> 模式已定义，因此我们可以在图中添加 <code>bar</code> 作为新的状态通道并写入其中。</p>
</li>
</ol>
<h3 id="归约器httpslanggraphcomcnconceptslow_level1htmlreducers-permanent-link">归约器<a href="https://langgraph.com.cn/concepts/low_level.1.html#reducers" title="Permanent link">¶</a></h3>
<p>归约器是理解节点更新如何应用于 <code>State</code> 的关键。<code>State</code> 中的每个键都有自己独立的归约函数。如果没有明确指定归约函数，则假定对该键的所有更新都应覆盖它。有几种不同类型的归约器，从默认类型的归约器开始：</p>
<h4 id="默认归约器httpslanggraphcomcnconceptslow_level1htmldefault-reducer-permanent-link">默认归约器<a href="https://langgraph.com.cn/concepts/low_level.1.html#default-reducer" title="Permanent link">¶</a></h4>
<p>以下两个示例展示了如何使用默认归约器：</p>
<p><strong>示例 A</strong></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-2-1&#34;&gt;from typing_extensions import TypedDict
&lt;span id=&#34;__span-2-2&#34;&gt;
&lt;span id=&#34;__span-2-3&#34;&gt;class State(TypedDict):
&lt;span id=&#34;__span-2-4&#34;&gt;    foo: int
&lt;span id=&#34;__span-2-5&#34;&gt;    bar: list[str]
</code></pre><p>在此示例中，未为任何键指定归约函数。假设图的输入是 <code>{&quot;foo&quot;: 1, &quot;bar&quot;: [&quot;hi&quot;]}</code>。然后假设第一个 <code>Node</code> 返回 <code>{&quot;foo&quot;: 2}</code>。这被视为对状态的更新。请注意，<code>Node</code> 不需要返回整个 <code>State</code> 模式——只需返回一个更新。应用此更新后，<code>State</code> 将变为 <code>{&quot;foo&quot;: 2, &quot;bar&quot;: [&quot;hi&quot;]}</code>。如果第二个节点返回 <code>{&quot;bar&quot;: [&quot;bye&quot;]}</code>，则 <code>State</code> 将变为 <code>{&quot;foo&quot;: 2, &quot;bar&quot;: [&quot;bye&quot;]}</code>。</p>
<p><strong>示例 B</strong></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-3-1&#34;&gt;from typing import Annotated
&lt;span id=&#34;__span-3-2&#34;&gt;from typing_extensions import TypedDict
&lt;span id=&#34;__span-3-3&#34;&gt;from operator import add
&lt;span id=&#34;__span-3-4&#34;&gt;
&lt;span id=&#34;__span-3-5&#34;&gt;class State(TypedDict):
&lt;span id=&#34;__span-3-6&#34;&gt;    foo: int
&lt;span id=&#34;__span-3-7&#34;&gt;    bar: Annotated[list[str], add]
</code></pre><p>在此示例中，我们使用 <code>Annotated</code> 类型为第二个键 (<code>bar</code>) 指定了一个归约函数 (<code>operator.add</code>)。请注意，第一个键保持不变。假设图的输入是 <code>{&quot;foo&quot;: 1, &quot;bar&quot;: [&quot;hi&quot;]}</code>。然后假设第一个 <code>Node</code> 返回 <code>{&quot;foo&quot;: 2}</code>。这被视为对状态的更新。请注意，<code>Node</code> 不需要返回整个 <code>State</code> 模式——只需返回一个更新。应用此更新后，<code>State</code> 将变为 <code>{&quot;foo&quot;: 2, &quot;bar&quot;: [&quot;hi&quot;]}</code>。如果第二个节点返回 <code>{&quot;bar&quot;: [&quot;bye&quot;]}</code>，则 <code>State</code> 将变为 <code>{&quot;foo&quot;: 2, &quot;bar&quot;: [&quot;hi&quot;, &quot;bye&quot;]}</code>。请注意，这里的 <code>bar</code> 键是通过将两个列表相加来更新的。</p>
<h3 id="在图状态中使用消息httpslanggraphcomcnconceptslow_level1htmlworking-with-messages-in-graph-state-permanent-link">在图状态中使用消息<a href="https://langgraph.com.cn/concepts/low_level.1.html#working-with-messages-in-graph-state" title="Permanent link">¶</a></h3>
<h4 id="为什么要使用消息httpslanggraphcomcnconceptslow_level1htmlwhy-use-messages-permanent-link">为什么要使用消息？<a href="https://langgraph.com.cn/concepts/low_level.1.html#why-use-messages" title="Permanent link">¶</a></h4>
<p>大多数现代 LLM 提供商都有一个聊天模型接口，它接受消息列表作为输入。LangChain 的<a href="https://python.langchain.ac.cn/docs/concepts/#chat-models"><code>ChatModel</code></a> 特别接受 <code>Message</code> 对象的列表作为输入。这些消息有多种形式，例如 <code>HumanMessage</code>（用户输入）或 <code>AIMessage</code>（LLM 响应）。要了解更多关于消息对象的信息，请参阅<a href="https://python.langchain.ac.cn/docs/concepts/#messages">此</a>概念指南。</p>
<h4 id="在图中使用消息httpslanggraphcomcnconceptslow_level1htmlusing-messages-in-your-graph-permanent-link">在图中使用消息<a href="https://langgraph.com.cn/concepts/low_level.1.html#using-messages-in-your-graph" title="Permanent link">¶</a></h4>
<p>在许多情况下，将之前的对话历史记录作为消息列表存储在图状态中很有帮助。为此，我们可以向图状态添加一个键（通道），该键存储 <code>Message</code> 对象的列表，并使用归约函数对其进行注释（参见下面示例中的 <code>messages</code> 键）。归约函数对于告诉图如何通过每次状态更新（例如，当节点发送更新时）来更新状态中的 <code>Message</code> 对象列表至关重要。如果您不指定归约器，则每次状态更新都将使用最新提供的值覆盖消息列表。如果您只想将消息简单地附加到现有列表，则可以使用 <code>operator.add</code> 作为归约器。</p>
<p>然而，您可能还希望手动更新图状态中的消息（例如，人工参与）。如果您使用 <code>operator.add</code>，则您发送到图的手动状态更新将被附加到现有消息列表，而不是更新现有消息。为避免这种情况，您需要一个能够跟踪消息 ID 并在更新时覆盖现有消息的归约器。为此，您可以使用预构建的 <code>add_messages</code> 函数。对于全新消息，它将简单地附加到现有列表；但它也会正确处理现有消息的更新。</p>
<h4 id="序列化httpslanggraphcomcnconceptslow_level1htmlserialization-permanent-link">序列化<a href="https://langgraph.com.cn/concepts/low_level.1.html#serialization" title="Permanent link">¶</a></h4>
<p>除了跟踪消息 ID 之外，每当在 <code>messages</code> 通道上收到状态更新时，<code>add_messages</code> 函数还会尝试将消息反序列化为 LangChain <code>Message</code> 对象。有关 LangChain 序列化/反序列化的更多信息，请参阅<a href="https://python.langchain.ac.cn/docs/how_to/serialization/">此处</a>。这允许以以下格式发送图输入/状态更新：</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-4-1&#34;&gt;# this is supported
&lt;span id=&#34;__span-4-2&#34;&gt;{&#34;messages&#34;: [HumanMessage(content=&#34;message&#34;)]}
&lt;span id=&#34;__span-4-3&#34;&gt;
&lt;span id=&#34;__span-4-4&#34;&gt;# and this is also supported
&lt;span id=&#34;__span-4-5&#34;&gt;{&#34;messages&#34;: [{&#34;type&#34;: &#34;human&#34;, &#34;content&#34;: &#34;message&#34;}]}
</code></pre><p>由于在使用 <code>add_messages</code> 时状态更新总是反序列化为 LangChain <code>Messages</code>，因此您应该使用点表示法来访问消息属性，例如 <code>state[&quot;messages&quot;][-1].content</code>。下面是一个使用 <code>add_messages</code> 作为其归约函数的图示例。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->AnyMessage<!-- raw HTML omitted --> | <!-- raw HTML omitted -->add_messages<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-5-1&#34;&gt;from langchain_core.messages import AnyMessage
&lt;span id=&#34;__span-5-2&#34;&gt;from langgraph.graph.message import add_messages
&lt;span id=&#34;__span-5-3&#34;&gt;from typing import Annotated
&lt;span id=&#34;__span-5-4&#34;&gt;from typing_extensions import TypedDict
&lt;span id=&#34;__span-5-5&#34;&gt;
&lt;span id=&#34;__span-5-6&#34;&gt;class GraphState(TypedDict):
&lt;span id=&#34;__span-5-7&#34;&gt;    messages: Annotated[list[AnyMessage], add_messages]
</code></pre><h4 id="messagesstatehttpslanggraphcomcnconceptslow_level1htmlmessagesstate-permanent-link">MessagesState<a href="https://langgraph.com.cn/concepts/low_level.1.html#messagesstate" title="Permanent link">¶</a></h4>
<p>由于在状态中包含消息列表非常常见，因此存在一个预构建的状态，称为 <code>MessagesState</code>，它使得使用消息变得容易。<code>MessagesState</code> 定义了一个单独的 <code>messages</code> 键，它是一个 <code>AnyMessage</code> 对象列表，并使用 <code>add_messages</code> 归约器。通常，除了消息之外还需要跟踪更多状态，因此我们看到人们会对此状态进行子类化并添加更多字段，例如：</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-6-1&#34;&gt;from langgraph.graph import MessagesState
&lt;span id=&#34;__span-6-2&#34;&gt;
&lt;span id=&#34;__span-6-3&#34;&gt;class State(MessagesState):
&lt;span id=&#34;__span-6-4&#34;&gt;    documents: list[str]
</code></pre><h2 id="节点httpslanggraphcomcnconceptslow_level1htmlnodes-permanent-link">节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#nodes" title="Permanent link">¶</a></h2>
<p>在 LangGraph 中，节点通常是 Python 函数（同步或异步），其中<strong>第一个</strong>位置参数是<a href="https://langgraph.com.cn/concepts/low_level.1.html#state">状态</a>，（可选地）<strong>第二个</strong>位置参数是“配置”，包含可选的<a href="https://langgraph.com.cn/concepts/low_level.1.html#configuration">可配置参数</a>（例如 <code>thread_id</code>）。</p>
<p>与 <code>NetworkX</code> 类似，您可以使用 [add_node](<a href="https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_node">https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_node</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->add_node<!-- raw HTML omitted -->&rdquo;) 方法将这些节点添加到图中：</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->RunnableConfig<!-- raw HTML omitted --> | <!-- raw HTML omitted -->StateGraph<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-7-1&#34;&gt;from typing_extensions import TypedDict
&lt;span id=&#34;__span-7-2&#34;&gt;
&lt;span id=&#34;__span-7-3&#34;&gt;from langchain_core.runnables import RunnableConfig
&lt;span id=&#34;__span-7-4&#34;&gt;from langgraph.graph import StateGraph
&lt;span id=&#34;__span-7-5&#34;&gt;
&lt;span id=&#34;__span-7-6&#34;&gt;class State(TypedDict):
&lt;span id=&#34;__span-7-7&#34;&gt;    input: str
&lt;span id=&#34;__span-7-8&#34;&gt;    results: str
&lt;span id=&#34;__span-7-9&#34;&gt;
&lt;span id=&#34;__span-7-10&#34;&gt;builder = StateGraph(State)
&lt;span id=&#34;__span-7-11&#34;&gt;
&lt;span id=&#34;__span-7-12&#34;&gt;
&lt;span id=&#34;__span-7-13&#34;&gt;def my_node(state: State, config: RunnableConfig):
&lt;span id=&#34;__span-7-14&#34;&gt;    print(&#34;In node: &#34;, config[&#34;configurable&#34;][&#34;user_id&#34;])
&lt;span id=&#34;__span-7-15&#34;&gt;    return {&#34;results&#34;: f&#34;Hello, {state[&#39;input&#39;]}!&#34;}
&lt;span id=&#34;__span-7-16&#34;&gt;
&lt;span id=&#34;__span-7-17&#34;&gt;
&lt;span id=&#34;__span-7-18&#34;&gt;# The second argument is optional
&lt;span id=&#34;__span-7-19&#34;&gt;def my_other_node(state: State):
&lt;span id=&#34;__span-7-20&#34;&gt;    return state
&lt;span id=&#34;__span-7-21&#34;&gt;
&lt;span id=&#34;__span-7-22&#34;&gt;
&lt;span id=&#34;__span-7-23&#34;&gt;builder.add_node(&#34;my_node&#34;, my_node)
&lt;span id=&#34;__span-7-24&#34;&gt;builder.add_node(&#34;other_node&#34;, my_other_node)
&lt;span id=&#34;__span-7-25&#34;&gt;...
</code></pre><p>在幕后，函数被转换为 <a href="https://python-api.langchain.ac.cn/en/latest/runnables/langchain_core.runnables.base.RunnableLambda.html#langchain_core.runnables.base.RunnableLambda">RunnableLambda</a>，这为您的函数添加了批处理和异步支持，以及原生跟踪和调试功能。</p>
<p>如果您向图中添加节点时未指定名称，它将获得与函数名称相同的默认名称。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-8-1&#34;&gt;builder.add_node(my_node)
&lt;span id=&#34;__span-8-2&#34;&gt;# You can then create edges to/from this node by referencing it as `&#34;my_node&#34;`
</code></pre><h3 id="start-节点httpslanggraphcomcnconceptslow_level1htmlstart-node-permanent-link"><code>START</code> 节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#start-node" title="Permanent link">¶</a></h3>
<p><code>START</code> 节点是一个特殊节点，代表将用户输入发送到图的节点。引用此节点的主要目的是确定应首先调用哪些节点。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->START<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-9-1&#34;&gt;from langgraph.graph import START
&lt;span id=&#34;__span-9-2&#34;&gt;
&lt;span id=&#34;__span-9-3&#34;&gt;graph.add_edge(START, &#34;node_a&#34;)
</code></pre><h3 id="end-节点httpslanggraphcomcnconceptslow_level1htmlend-node-permanent-link"><code>END</code> 节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#end-node" title="Permanent link">¶</a></h3>
<p><code>END</code> 节点是一个特殊节点，代表终止节点。当您想表示哪些边在完成操作后没有后续动作时，会引用此节点。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-10-1&#34;&gt;from langgraph.graph import END
&lt;span id=&#34;__span-10-2&#34;&gt;
&lt;span id=&#34;__span-10-3&#34;&gt;graph.add_edge(&#34;node_a&#34;, END)
</code></pre><h3 id="节点缓存httpslanggraphcomcnconceptslow_level1htmlnode-caching-permanent-link">节点缓存<a href="https://langgraph.com.cn/concepts/low_level.1.html#node-caching" title="Permanent link">¶</a></h3>
<p>LangGraph 支持根据节点的输入缓存任务/节点。要使用缓存：</p>
<ul>
<li>编译图时（或指定入口点时）指定缓存。</li>
<li>为节点指定缓存策略。每个缓存策略支持：
<ul>
<li><code>key_func</code> 用于根据节点输入生成缓存键，默认为使用 pickle 对输入进行 <code>hash</code>。</li>
<li><code>ttl</code>，缓存的存活时间（秒）。如果未指定，缓存将永不过期。</li>
</ul>
</li>
</ul>
<p>例如</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->StateGraph<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-11-1&#34;&gt;import time
&lt;span id=&#34;__span-11-2&#34;&gt;from typing_extensions import TypedDict
&lt;span id=&#34;__span-11-3&#34;&gt;from langgraph.graph import StateGraph
&lt;span id=&#34;__span-11-4&#34;&gt;from langgraph.cache.memory import InMemoryCache
&lt;span id=&#34;__span-11-5&#34;&gt;from langgraph.types import CachePolicy
&lt;span id=&#34;__span-11-6&#34;&gt;
&lt;span id=&#34;__span-11-7&#34;&gt;
&lt;span id=&#34;__span-11-8&#34;&gt;class State(TypedDict):
&lt;span id=&#34;__span-11-9&#34;&gt;    x: int
&lt;span id=&#34;__span-11-10&#34;&gt;    result: int
&lt;span id=&#34;__span-11-11&#34;&gt;
&lt;span id=&#34;__span-11-12&#34;&gt;
&lt;span id=&#34;__span-11-13&#34;&gt;builder = StateGraph(State)
&lt;span id=&#34;__span-11-14&#34;&gt;
&lt;span id=&#34;__span-11-15&#34;&gt;
&lt;span id=&#34;__span-11-16&#34;&gt;def expensive_node(state: State) -&amp;gt; dict[str, int]:
&lt;span id=&#34;__span-11-17&#34;&gt;    # expensive computation
&lt;span id=&#34;__span-11-18&#34;&gt;    time.sleep(2)
&lt;span id=&#34;__span-11-19&#34;&gt;    return {&#34;result&#34;: state[&#34;x&#34;] * 2}
&lt;span id=&#34;__span-11-20&#34;&gt;
&lt;span id=&#34;__span-11-21&#34;&gt;
&lt;span id=&#34;__span-11-22&#34;&gt;builder.add_node(&#34;expensive_node&#34;, expensive_node, cache_policy=CachePolicy(ttl=3))
&lt;span id=&#34;__span-11-23&#34;&gt;builder.set_entry_point(&#34;expensive_node&#34;)
&lt;span id=&#34;__span-11-24&#34;&gt;builder.set_finish_point(&#34;expensive_node&#34;)
&lt;span id=&#34;__span-11-25&#34;&gt;
&lt;span id=&#34;__span-11-26&#34;&gt;graph = builder.compile(cache=InMemoryCache())
&lt;span id=&#34;__span-11-27&#34;&gt;
&lt;span id=&#34;__span-11-28&#34;&gt;print(graph.invoke({&#34;x&#34;: 5}, stream_mode=&#39;updates&#39;))  
&lt;span id=&#34;__span-11-29&#34;&gt;[{&#39;expensive_node&#39;: {&#39;result&#39;: 10}}]
&lt;span id=&#34;__span-11-30&#34;&gt;print(graph.invoke({&#34;x&#34;: 5}, stream_mode=&#39;updates&#39;))  
&lt;span id=&#34;__span-11-31&#34;&gt;[{&#39;expensive_node&#39;: {&#39;result&#39;: 10}, &#39;__metadata__&#39;: {&#39;cached&#39;: True}}]
</code></pre><h2 id="边httpslanggraphcomcnconceptslow_level1htmledges-permanent-link">边<a href="https://langgraph.com.cn/concepts/low_level.1.html#edges" title="Permanent link">¶</a></h2>
<p>边定义了逻辑如何路由以及图如何决定停止。这是代理工作方式以及不同节点之间如何通信的重要组成部分。边有几种主要类型：</p>
<ul>
<li>普通边：直接从一个节点到下一个节点。</li>
<li>条件边：调用函数来确定接下来要到哪个（或哪些）节点。</li>
<li>入口点：当用户输入到达时首先调用哪个节点。</li>
<li>条件入口点：调用函数来确定当用户输入到达时首先调用哪个（或哪些）节点。</li>
</ul>
<p>一个节点可以有多个出边。如果一个节点有多个出边，则所有这些目标节点都将作为下一个超步的一部分并行执行。</p>
<h3 id="普通边httpslanggraphcomcnconceptslow_level1htmlnormal-edges-permanent-link">普通边<a href="https://langgraph.com.cn/concepts/low_level.1.html#normal-edges" title="Permanent link">¶</a></h3>
<p>如果您<strong>总是</strong>想从节点 A 到节点 B，您可以直接使用 [add_edge](<a href="https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_edge">https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_edge</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->add_edge<!-- raw HTML omitted -->&rdquo;) 方法。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-12-1&#34;&gt;graph.add_edge(&#34;node_a&#34;, &#34;node_b&#34;)
</code></pre><h3 id="条件边httpslanggraphcomcnconceptslow_level1htmlconditional-edges-permanent-link">条件边<a href="https://langgraph.com.cn/concepts/low_level.1.html#conditional-edges" title="Permanent link">¶</a></h3>
<p>如果您想<strong>选择性地</strong>路由到一条或多条边（或选择性地终止），您可以使用 [add_conditional_edges](<a href="https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_conditional_edges">https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_conditional_edges</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->add_conditional_edges<!-- raw HTML omitted -->&rdquo;) 方法。此方法接受节点名称和一个在该节点执行后要调用的“路由函数”。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-13-1&#34;&gt;graph.add_conditional_edges(&#34;node_a&#34;, routing_function)
</code></pre><p>与节点类似，<code>routing_function</code> 接受图的当前 <code>state</code> 并返回一个值。</p>
<p>默认情况下，<code>routing_function</code> 的返回值用作下一个接收状态的节点（或节点列表）的名称。所有这些节点都将作为下一个超步的一部分并行运行。</p>
<p>您可以选择提供一个字典，将 <code>routing_function</code> 的输出映射到下一个节点的名称。</p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-14-1&#34;&gt;graph.add_conditional_edges(&#34;node_a&#34;, routing_function, {True: &#34;node_b&#34;, False: &#34;node_c&#34;})
</code></pre><p>提示</p>
<p>如果您想在单个函数中结合状态更新和路由，请使用<a href="https://langgraph.com.cn/concepts/low_level.1.html#command"><code>Command</code></a> 而不是条件边。</p>
<h3 id="入口点httpslanggraphcomcnconceptslow_level1htmlentry-point-permanent-link">入口点<a href="https://langgraph.com.cn/concepts/low_level.1.html#entry-point" title="Permanent link">¶</a></h3>
<p>入口点是图启动时运行的第一个节点。您可以使用从虚拟 [<code>START</code>](<a href="https://langgraph.com.cn/reference/constants/index.html#langgraph.constants.START">https://langgraph.com.cn/reference/constants/index.html#langgraph.constants.START</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->START<!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->module-attribute<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->&rdquo;) 节点到第一个要执行的节点的 [<code>add_edge</code>](<a href="https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_edge">https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_edge</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->add_edge<!-- raw HTML omitted -->&rdquo;) 方法来指定图的入口。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->START<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-15-1&#34;&gt;from langgraph.graph import START
&lt;span id=&#34;__span-15-2&#34;&gt;
&lt;span id=&#34;__span-15-3&#34;&gt;graph.add_edge(START, &#34;node_a&#34;)
</code></pre><h3 id="条件入口点httpslanggraphcomcnconceptslow_level1htmlconditional-entry-point-permanent-link">条件入口点<a href="https://langgraph.com.cn/concepts/low_level.1.html#conditional-entry-point" title="Permanent link">¶</a></h3>
<p>条件入口点允许您根据自定义逻辑在不同的节点开始。您可以使用虚拟 [<code>START</code>](<a href="https://langgraph.com.cn/reference/constants/index.html#langgraph.constants.START">https://langgraph.com.cn/reference/constants/index.html#langgraph.constants.START</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->START<!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->module-attribute<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->&rdquo;) 节点的 [<code>add_conditional_edges</code>](<a href="https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_conditional_edges">https://langgraph.com.cn/reference/graphs/index.html#langgraph.graph.state.StateGraph.add_conditional_edges</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->add_conditional_edges<!-- raw HTML omitted -->&rdquo;) 来实现此目的。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->API 参考：<!-- raw HTML omitted -->START<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-16-1&#34;&gt;from langgraph.graph import START
&lt;span id=&#34;__span-16-2&#34;&gt;
&lt;span id=&#34;__span-16-3&#34;&gt;graph.add_conditional_edges(START, routing_function)
</code></pre><p>您可以选择提供一个字典，将 <code>routing_function</code> 的输出映射到下一个节点的名称。</p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-17-1&#34;&gt;graph.add_conditional_edges(START, routing_function, {True: &#34;node_b&#34;, False: &#34;node_c&#34;})
</code></pre><h2 id="sendhttpslanggraphcomcnconceptslow_level1htmlsend-permanent-link"><code>Send</code><a href="https://langgraph.com.cn/concepts/low_level.1.html#send" title="Permanent link">¶</a></h2>
<p>默认情况下，<code>Nodes</code> 和 <code>Edges</code> 是预先定义的，并在同一个共享状态上操作。然而，在某些情况下，确切的边可能无法预先知道，或者您可能希望同时存在不同版本的 <code>State</code>。一个常见的例子是 <a href="https://langgraph.com.cn/how-tos/map-reduce/index.html">map-reduce</a> 设计模式。在此设计模式中，第一个节点可能会生成一个对象列表，您可能希望将某些其他节点应用于所有这些对象。对象的数量可能无法预先知道（这意味着边的数量可能无法知道），并且下游 <code>Node</code> 的输入 <code>State</code> 应该不同（每个生成的对象对应一个）。</p>
<p>为了支持这种设计模式，LangGraph 支持从条件边返回 [<code>Send</code>](<a href="https://langgraph.com.cn/reference/types/index.html#langgraph.types.Send">https://langgraph.com.cn/reference/types/index.html#langgraph.types.Send</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->Send<!-- raw HTML omitted -->&rdquo;) 对象。<code>Send</code> 接受两个参数：第一个是节点名称，第二个是要传递给该节点的状态。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-18-1&#34;&gt;def continue_to_jokes(state: OverallState):
&lt;span id=&#34;__span-18-2&#34;&gt;    return [Send(&#34;generate_joke&#34;, {&#34;subject&#34;: s}) for s in state[&#39;subjects&#39;]]
&lt;span id=&#34;__span-18-3&#34;&gt;
&lt;span id=&#34;__span-18-4&#34;&gt;graph.add_conditional_edges(&#34;node_a&#34;, continue_to_jokes)
</code></pre><h2 id="commandhttpslanggraphcomcnconceptslow_level1htmlcommand-permanent-link"><code>Command</code><a href="https://langgraph.com.cn/concepts/low_level.1.html#command" title="Permanent link">¶</a></h2>
<p>将控制流（边）和状态更新（节点）结合起来会很有用。例如，您可能希望在同一个节点中既执行状态更新又决定下一个要去的节点。LangGraph 提供了一种通过从节点函数返回 [<code>Command</code>](<a href="https://langgraph.com.cn/reference/types/index.html#langgraph.types.Command">https://langgraph.com.cn/reference/types/index.html#langgraph.types.Command</a> &ldquo;<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->Command<!-- raw HTML omitted --> <!-- raw HTML omitted --> <!-- raw HTML omitted --><!-- raw HTML omitted -->dataclass<!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted -->&rdquo;) 对象来实现此目的的方法：</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-19-1&#34;&gt;def my_node(state: State) -&amp;gt; Command[Literal[&#34;my_other_node&#34;]]:
&lt;span id=&#34;__span-19-2&#34;&gt;    return Command(
&lt;span id=&#34;__span-19-3&#34;&gt;        # state update
&lt;span id=&#34;__span-19-4&#34;&gt;        update={&#34;foo&#34;: &#34;bar&#34;},
&lt;span id=&#34;__span-19-5&#34;&gt;        # control flow
&lt;span id=&#34;__span-19-6&#34;&gt;        goto=&#34;my_other_node&#34;
&lt;span id=&#34;__span-19-7&#34;&gt;    )
</code></pre><p>使用 <code>Command</code>，您还可以实现动态控制流行为（与<a href="https://langgraph.com.cn/concepts/low_level.1.html#conditional-edges">条件边</a>相同）。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-20-1&#34;&gt;def my_node(state: State) -&amp;gt; Command[Literal[&#34;my_other_node&#34;]]:
&lt;span id=&#34;__span-20-2&#34;&gt;    if state[&#34;foo&#34;] == &#34;bar&#34;:
&lt;span id=&#34;__span-20-3&#34;&gt;        return Command(update={&#34;foo&#34;: &#34;baz&#34;}, goto=&#34;my_other_node&#34;)
</code></pre><p>重要提示</p>
<p>在节点函数中返回 <code>Command</code> 时，您必须添加返回类型注解，其中包含节点路由到的节点名称列表，例如 <code>Command[Literal[&quot;my_other_node&quot;]]</code>。这对于图的渲染是必需的，并告诉 LangGraph <code>my_node</code> 可以导航到 <code>my_other_node</code>。</p>
<p>请查看<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#combine-control-flow-and-state-updates-with-command">此操作指南</a>，了解如何使用 <code>Command</code> 的端到端示例。</p>
<h3 id="什么时候应该使用-command-而不是条件边httpslanggraphcomcnconceptslow_level1htmlwhen-should-i-use-command-instead-of-conditional-edges-permanent-link">什么时候应该使用 Command 而不是条件边？<a href="https://langgraph.com.cn/concepts/low_level.1.html#when-should-i-use-command-instead-of-conditional-edges" title="Permanent link">¶</a></h3>
<p>当您需要<strong>同时</strong>更新图状态<strong>和</strong>路由到不同节点时，请使用 <code>Command</code>。例如，在实现<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs">多代理交接</a>时，路由到不同代理并向其传递某些信息非常重要。</p>
<p>使用<a href="https://langgraph.com.cn/concepts/low_level.1.html#conditional-edges">条件边</a>可在节点之间有条件地路由，而无需更新状态。</p>
<h3 id="导航到父图中的节点httpslanggraphcomcnconceptslow_level1htmlnavigating-to-a-node-in-a-parent-graph-permanent-link">导航到父图中的节点<a href="https://langgraph.com.cn/concepts/low_level.1.html#navigating-to-a-node-in-a-parent-graph" title="Permanent link">¶</a></h3>
<p>如果您正在使用<a href="https://langgraph.com.cn/concepts/subgraphs.1.html">子图</a>，您可能希望从子图中的一个节点导航到不同的子图（即父图中的不同节点）。为此，您可以在 <code>Command</code> 中指定 <code>graph=Command.PARENT</code>。</p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-21-1&#34;&gt;def my_node(state: State) -&amp;gt; Command[Literal[&#34;other_subgraph&#34;]]:
&lt;span id=&#34;__span-21-2&#34;&gt;    return Command(
&lt;span id=&#34;__span-21-3&#34;&gt;        update={&#34;foo&#34;: &#34;bar&#34;},
&lt;span id=&#34;__span-21-4&#34;&gt;        goto=&#34;other_subgraph&#34;,  # where `other_subgraph` is a node in the parent graph
&lt;span id=&#34;__span-21-5&#34;&gt;        graph=Command.PARENT
&lt;span id=&#34;__span-21-6&#34;&gt;    )
</code></pre><p>注意</p>
<p>将 <code>graph</code> 设置为 <code>Command.PARENT</code> 将导航到最近的父图。</p>
<p>使用 <code>Command.PARENT</code> 进行状态更新</p>
<p>当您从子图节点向父图节点发送更新时，对于父图和子图<a href="https://langgraph.com.cn/concepts/low_level.1.html#schema">状态模式</a>都共享的键，您<strong>必须</strong>在父图状态中为您正在更新的键定义一个<a href="https://langgraph.com.cn/concepts/low_level.1.html#reducers">归约器</a>。请参阅<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#navigate-to-a-node-in-a-parent-graph">此示例</a>。</p>
<p>这在实现<a href="https://langgraph.com.cn/concepts/multi_agent.1.html#handoffs">多代理交接</a>时特别有用。</p>
<p>有关详细信息，请查看<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#navigate-to-a-node-in-a-parent-graph">本指南</a>。</p>
<h3 id="在工具内部使用httpslanggraphcomcnconceptslow_level1htmlusing-inside-tools-permanent-link">在工具内部使用<a href="https://langgraph.com.cn/concepts/low_level.1.html#using-inside-tools" title="Permanent link">¶</a></h3>
<p>一个常见的使用场景是从工具内部更新图状态。例如，在客户支持应用程序中，您可能希望在对话开始时根据客户的帐号或 ID 查找客户信息。</p>
<p>有关详细信息，请参阅<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#use-inside-tools">本指南</a>。</p>
<h3 id="人工参与httpslanggraphcomcnconceptslow_level1htmlhuman-in-the-loop-permanent-link">人工参与<a href="https://langgraph.com.cn/concepts/low_level.1.html#human-in-the-loop" title="Permanent link">¶</a></h3>
<p><code>Command</code> 是人工参与工作流的重要组成部分：当使用 <code>interrupt()</code> 收集用户输入时，随后通过 <code>Command(resume=&quot;User input&quot;)</code> 提供输入并恢复执行。有关更多信息，请查看<a href="https://langgraph.com.cn/concepts/human_in_the_loop.1.html">此概念指南</a>。</p>
<h2 id="图迁移httpslanggraphcomcnconceptslow_level1htmlgraph-migrations-permanent-link">图迁移<a href="https://langgraph.com.cn/concepts/low_level.1.html#graph-migrations" title="Permanent link">¶</a></h2>
<p>即使使用检查点来跟踪状态，LangGraph 也能轻松处理图定义（节点、边和状态）的迁移。</p>
<ul>
<li>对于图末尾的线程（即未中断的线程），您可以更改图的整个拓扑结构（即所有节点和边，删除、添加、重命名等）。</li>
<li>对于当前已中断的线程，我们支持除重命名/删除节点之外的所有拓扑更改（因为该线程现在可能即将进入一个不再存在的节点）——如果这是一个障碍，请联系我们，我们可以优先提供解决方案。</li>
<li>对于修改状态，我们完全支持添加和删除键的向后和向前兼容性。</li>
<li>已重命名的状态键会在现有线程中丢失其保存的状态。</li>
<li>类型以不兼容方式更改的状态键目前可能会在具有更改前状态的线程中导致问题——如果这是一个障碍，请联系我们，我们可以优先提供解决方案。</li>
</ul>
<h2 id="配置httpslanggraphcomcnconceptslow_level1htmlconfiguration-permanent-link">配置<a href="https://langgraph.com.cn/concepts/low_level.1.html#configuration" title="Permanent link">¶</a></h2>
<p>创建图时，您还可以将图的某些部分标记为可配置。这通常是为了方便在模型或系统提示之间切换。这允许您创建一个单一的“认知架构”（图），但拥有它的多个不同实例。</p>
<p>创建图时，您可以选择指定一个 <code>config_schema</code>。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-22-1&#34;&gt;class ConfigSchema(TypedDict):
&lt;span id=&#34;__span-22-2&#34;&gt;    llm: str
&lt;span id=&#34;__span-22-3&#34;&gt;
&lt;span id=&#34;__span-22-4&#34;&gt;graph = StateGraph(State, config_schema=ConfigSchema)
</code></pre><p>然后您可以使用 <code>configurable</code> 配置字段将此配置传递到图中。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-23-1&#34;&gt;config = {&#34;configurable&#34;: {&#34;llm&#34;: &#34;anthropic&#34;}}
&lt;span id=&#34;__span-23-2&#34;&gt;
&lt;span id=&#34;__span-23-3&#34;&gt;graph.invoke(inputs, config=config)
</code></pre><p>然后您可以在节点或条件边内部访问和使用此配置。</p>
<pre tabindex="0"><code>&lt;span id=&#34;__span-24-1&#34;&gt;def node_a(state, config):
&lt;span id=&#34;__span-24-2&#34;&gt;    llm_type = config.get(&#34;configurable&#34;, {}).get(&#34;llm&#34;, &#34;openai&#34;)
&lt;span id=&#34;__span-24-3&#34;&gt;    llm = get_llm(llm_type)
&lt;span id=&#34;__span-24-4&#34;&gt;    ...
</code></pre><p>有关配置的完整细分，请参阅<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#add-runtime-configuration">本指南</a>。</p>
<h3 id="递归限制httpslanggraphcomcnconceptslow_level1htmlrecursion-limit-permanent-link">递归限制<a href="https://langgraph.com.cn/concepts/low_level.1.html#recursion-limit" title="Permanent link">¶</a></h3>
<p>递归限制设置了图在单次执行期间可以执行的<a href="https://langgraph.com.cn/concepts/low_level.1.html#graphs">超步</a>的最大数量。一旦达到限制，LangGraph 将引发 <code>GraphRecursionError</code>。默认情况下，此值设置为 25 步。递归限制可以在运行时在任何图上设置，并通过配置字典传递给 <code>.invoke</code>/<code>.stream</code>。重要的是，<code>recursion_limit</code> 是一个独立的 <code>config</code> 键，不应像所有其他用户定义的配置一样传递到 <code>configurable</code> 键中。请参阅以下示例：</p>
<pre tabindex="0"><code>&lt;code tabindex=&#34;0&#34;&gt;&lt;span id=&#34;__span-25-1&#34;&gt;graph.invoke(inputs, config={&#34;recursion_limit&#34;: 5, &#34;configurable&#34;:{&#34;llm&#34;: &#34;anthropic&#34;}})
</code></pre><p>阅读<a href="https://langgraph.com.cn/how-tos/recursion-limit/index.html">此操作指南</a>以了解有关递归限制如何工作的更多信息。</p>
<h2 id="可视化httpslanggraphcomcnconceptslow_level1htmlvisualization-permanent-link">可视化<a href="https://langgraph.com.cn/concepts/low_level.1.html#visualization" title="Permanent link">¶</a></h2>
<p>能够可视化图通常是件好事，尤其是当它们变得更复杂时。LangGraph 提供了几种内置的图可视化方法。有关更多信息，请参阅<a href="https://langgraph.com.cn/how-tos/graph-api.1.html#visualize-your-graph">此操作指南</a>。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://index.zshipu.com/ai002">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://index.zshipu.com/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-2/">https://index.zshipu.com/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-2/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-10/">概述 - LangChain 框架 (10) --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%BF%B0-LangChain-%E6%A1%86%E6%9E%B6-1/">概述 - LangChain 框架 (1) --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%A6%82%E8%A7%88-LangChain-%E6%A1%86%E6%9E%B6/">概览 - LangChain 框架 --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E7%B3%BB%E7%BB%9F-LangChain-%E6%A1%86%E6%9E%B6/">构建多智能体系统 - LangChain 框架 --知识铺</a></li>
        
        <li><a href="/ai002/post/20251125/%E6%9C%89%E7%82%B9%E5%8E%89%E5%AE%B3/">有点厉害。。 --知识铺</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            没有标签
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-index"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2026 <a href="https://index.zshipu.com/ai002">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/ai002/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://index.zshipu.com/ai002/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://index.zshipu.com/ai002">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/Skills-%E7%9C%9F%E9%A6%99%E4%BD%86%E9%9D%9EClaude%E6%A8%A1%E5%9E%8B%E6%80%8E%E4%B9%88%E5%8A%9E/" title="Skills 真香，但非Claude模型怎么办？ --知识铺">Skills 真香，但非Claude模型怎么办？ --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E9%93%B6%E5%BC%B9%E8%BF%98%E6%98%AF%E6%9E%B7%E9%94%81Claude-Agent-SDK-%E7%9A%84%E6%9E%B6%E6%9E%84%E7%9C%9F%E7%9B%B8/" title="银弹还是枷锁？Claude Agent SDK 的架构真相 --知识铺">银弹还是枷锁？Claude Agent SDK 的架构真相 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E5%BA%94%E7%94%A8Beta%E8%B5%B7/" title="应用Beta起 --知识铺">应用Beta起 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/AI%E5%BA%94%E7%94%A8%E6%96%B0%E9%80%BB%E8%BE%91%E5%BC%95%E7%88%86%E5%9C%A8%E5%8D%B3%E9%99%84%E8%82%A1/" title="AI应用新逻辑，引爆在即！（附股） --知识铺">AI应用新逻辑，引爆在即！（附股） --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/agentskillsagentskills-Agent-Skills-%E7%9A%84%E8%A7%84%E8%8C%83%E5%92%8C%E6%96%87%E6%A1%A3---agentskillsagentskills-Specification-and-documentation-for-Agent-Skills/" title="agentskillsagentskills Agent Skills 的规范和文档 --- agentskillsagentskills Specification and documentation for Agent Skills --知识铺">agentskillsagentskills Agent Skills 的规范和文档 --- agentskillsagentskills Specification and documentation for Agent Skills --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/2026%E5%B9%B4AI%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF%E6%A0%88%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Agent-Skill%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%8A%AB%E9%9C%B2%E6%9E%B6%E6%9E%84%E4%BC%81%E4%B8%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Agent-Skill%E4%B8%BA%E9%80%9A%E7%94%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%85%8D%E5%A4%87%E7%B2%BE%E5%87%86%E7%9A%84%E5%B2%97%E4%BD%8DSOP-%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA-%E8%85%BE%E8%AE%AF%E4%BA%91/" title="2026年AI应用技术栈：深度剖析Agent Skill“渐进式披露”架构！企业如何利用Agent Skill，为通用大模型配备精准的“岗位SOP”？-腾讯云开发者社区-腾讯云 --知识铺">2026年AI应用技术栈：深度剖析Agent Skill“渐进式披露”架构！企业如何利用Agent Skill，为通用大模型配备精准的“岗位SOP”？-腾讯云开发者社区-腾讯云 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E5%BF%85%E8%97%8F%E5%B9%B2%E8%B4%A7%E5%A4%A7%E6%A8%A1%E5%9E%8BAgent%E6%8A%80%E8%83%BD%E5%8C%85Agent-Skills%E6%A0%87%E5%87%86%E5%8C%96%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%E8%AE%A9AI%E5%BC%80%E5%8F%91%E5%83%8F%E6%90%AD%E7%A7%AF%E6%9C%A8%E4%B8%80%E6%A0%B7%E7%AE%80%E5%8D%95-CSDN%E5%8D%9A%E5%AE%A2/" title="【必藏干货】大模型Agent技能包：Agent Skills标准化框架详解，让AI开发像搭积木一样简单-CSDN博客 --知识铺">【必藏干货】大模型Agent技能包：Agent Skills标准化框架详解，让AI开发像搭积木一样简单-CSDN博客 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/Agent-Skills-%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97%E5%85%A5%E9%97%A8%E7%B2%BE%E9%80%9A%E9%A2%84%E6%B5%8B-%E7%9F%A5%E4%B9%8E/" title="Agent Skills 终极指南：入门、精通、预测 - 知乎 --知识铺">Agent Skills 终极指南：入门、精通、预测 - 知乎 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E9%AA%97%E4%BD%A0%E7%9A%84%E5%85%B6%E5%AE%9EAI%E6%A0%B9%E6%9C%AC%E4%B8%8D%E9%9C%80%E8%A6%81%E9%82%A3%E4%B9%88%E5%A4%9A%E6%8F%90%E7%A4%BA%E8%AF%8DAI_%E6%96%B0%E6%B5%AA%E7%A7%91%E6%8A%80_%E6%96%B0%E6%B5%AA%E7%BD%91/" title="骗你的！其实AI根本不需要那么多提示词AI_新浪科技_新浪网 --知识铺">骗你的！其实AI根本不需要那么多提示词AI_新浪科技_新浪网 --知识铺</a>
    </li>
    
    <li>
        <a href="https://index.zshipu.com/ai002/post/20260112/%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F%E7%9A%84%E7%94%A8-Claude-Code-%E5%B8%AE%E4%BD%A0%E5%88%9B%E5%BB%BA-PPT-%E7%94%9F%E6%88%90-Skills_%E8%85%BE%E8%AE%AF%E6%96%B0%E9%97%BB/" title="简单快速的用 Claude Code 帮你创建 PPT 生成 Skills_腾讯新闻 --知识铺">简单快速的用 Claude Code 帮你创建 PPT 生成 Skills_腾讯新闻 --知识铺</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利派送</h3>
    <ul class="widget-list">
        
        <li>
            <a href="https://pplx.ai/sblig3912" title="一起上 Comet，AI 工具免费用还送钱～" target="_blank" style="color:red">
                
                    <img src="https://cdn.jsdelivr.net/gh/zshipu/images/2025/202510250843697.png">
                
            </a>
        </li>
        
        <li>
            <a href="https://pplx.ai/sblig3912" title="邀请有礼 🎁 一起用 Comet，AI 助你更高效还送钱！" target="_blank" style="color:red">
                
                    <img src="https://cdn.jsdelivr.net/gh/zshipu/images/2025/202510250850822.png">
                
            </a>
        </li>
        
        <li>
            <a href="https://pplx.ai/sblig3912" title="AI 工具真香！我用的 Comet 免费送一个月 Pro～" target="_blank" style="color:red">
                
                    <img src="https://cdn.jsdelivr.net/gh/zshipu/images/2025/202510250851688.png">
                
            </a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title"><a href='/ai002/categories/'>分类</a></h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/ai002/tags/'>标签</a></h3>
<div class="tagcloud">
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://index.zshipu.com/ai002/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>